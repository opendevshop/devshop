<?php

/**
 * @file devshop_github.module
 */

require_once('includes/queue.inc');

use Symfony\Component\Yaml\Yaml;

/**
 * Grab an authenticated GitHub client.
 *
 * If a devshop_github_token is not found, it will attempt to use the Public API.
 *
 * @param bool $public
 *   Set to TRUE to skip authentication.
 *
 * @return \Github\Client
 * @throws Exception
 */
function devshop_github_client($public = FALSE) {
  $client = new \Github\Client();

  // Check for missing token. Set $public to TRUE.
  if (empty(variable_get('devshop_github_token'))) {
    $public = variable_get('devshop_github_use_public_api_if_no_token', TRUE);
  }

  // If not public...
  if (!$public) {

    // Throw exception if token is missing.
    if (empty(variable_get('devshop_github_token'))) {
      throw new \Exception(t('There is no GitHub Token set.'));
    }

    // Set token in client.
    $client->authenticate(variable_get('devshop_github_token'), Github\Client::AUTH_HTTP_TOKEN);
    try {
      // If currentUser()->show() worked, we know we are authenticated.
      $client->currentUser()->show();
      return $client;
    }
    catch (Exception $e) {
      // If error, set_message and throw the exception upstream.
      drupal_set_message(t('Error validating GitHub token: ') . $e->getMessage(), 'error');
      throw $e;
    }
  }
  else {
    // return an unauthenticated client, use for public requests.
    return $client;
  }
}


/**
 * Implements hook_menu().
 */
function devshop_github_menu() {
  $items = array();

  $items['admin/devshop/github'] = array(
    'title' => 'GitHub',
    'description' => 'DevShop GitHub Integration Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('devshop_github_settings_form'),
    'access arguments' => array('administer projects'),
    'file' => 'admin.inc',
    'file path' => drupal_get_path('module', 'devshop_github') . '/includes',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/devshop/github/add-key'] = array(
    'title' => 'Add public key to GitHub Account',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('devshop_github_add_key_to_account'),
    'access arguments' => array('administer projects'),
    'file' => 'add-key.inc',
    'file path' => drupal_get_path('module', 'devshop_github') . '/includes',
    'type' => MENU_CALLBACK,
  );
  $items['admin/devshop/github/load-repos'] = array(
    'title' => 'Load all repos that the user has access to.',
    'page callback' => 'devshop_github_get_repositories_page',
    'access arguments' => array('administer projects'),
    'file' => 'admin.inc',
    'file path' => drupal_get_path('module', 'devshop_github') . '/includes',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter() for project_node_form().
 */
function devshop_github_form_project_node_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#node'];

  if ($node->project->git_provider != 'github') {
    return;
  }

  //All settings git pull in project page
  $form['project']['settings']['github'] = array(
      '#type' => 'fieldset',
      '#group' => 'project_settings',
      '#collapsible' => TRUE,
      '#collapsed' => arg(1) != $node->nid,
      '#title' => t('GitHub Integration'),
      '#weight' => -10,
  );
  $form['project']['settings']['deploy']['default_hooks']['#weight'] = -9;

  // If Pull Requests were found in the environment, enable PR environments by default.
  $prs = devshop_github_client()->pullRequests()->all($node->project->github_owner, $node->project->github_repo);
  $pr_count = count($prs);
  if ($pr_count > 0) {
    $form['project']['settings']['github']['found_prs'] = array(
      '#type' => 'markup',
      '#prefix' => '<div class="alert alert-success">',
      '#suffix' => '</div>',
      '#markup' => t('Pull Request Environments are enabled because !link. Please confirm your desired settings below.', array(
        '!link' => l(format_plural($pr_count, t('there is 1 open Pull Request in your project'), t('there are @number open Pull Requests in your project', array('@number' => $pr_count))), $node->project->git_repo_url . '/pulls', array(
          'attributes' => array(
            'target' => '_blank',
          ),
        )),
      )),
    );
    $pr_envs_default_value = 1;
  }
  else {
    $pr_envs_default_value = isset($node->project->settings->github) ? $node->project->settings->github['pull_request_environments'] : 0;
  }

  $form['project']['settings']['github']['pull_request_environments'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable Pull Request Environments <div class="help-block">Automatically create a copy of your site with the code from a Pull Request\'s branch.</div>'),
      '#default_value' => $pr_envs_default_value,
  );

  $form['project']['settings']['github']['pull_request_create_policy'] = array(
    '#title' => t('Environment Creation Policy'),
    '#type' => 'radios',
    '#field_prefix' => '<span class="text-success">' . format_plural($pr_count,
      t('The project has one open Pull Request'),
      t('The project has @number open Pull Requests', array(
        '@number' => $pr_count,
      )) . '</span>'
    ),
    '#options' => array(
      'all' => t('Create Environments for all open Pull Requests.  <div class="help-block">Environments will be created and deleted as Pull Requests are opened, closed, and re-opened.</div>'),
      'create' => t('Only Create Environments when Pull Requests are opened or re-opened. <div class="help-block">Recommended if you have a large number of open Pull Requests or if PRs have unstable or unknown code.</div>'),
    ),
    '#default_value' => !empty($node->project->settings->github['pull_request_create_policy'])?
      $node->project->settings->github['pull_request_create_policy']:
      'all',
    '#states' => array(
      'visible' => array(
        ':input[name="project[settings][github][pull_request_environments]"]' => array('checked' => TRUE),
      ),
    ),
  );

  // Delete Pull Request environments?
  $form['project']['settings']['github']['pull_request_environments_delete'] = array(
      '#type' => 'checkbox',
      '#title' => t('Delete Pull Request Environments <div class="help-block">When Pull Requests are merged or closed, delete the environment.</div>'),
      '#default_value' => isset($node->project->settings->github) ? $node->project->settings->github['pull_request_environments_delete'] : 1,
// @TODO: Putting description in "help-block" right after title looks MUCH better and has better UX because the description is clickable. Put this in the theme layer.
//      '#description' => t('When Pull Requests are merged or closed, delete the environment.'),
      '#states' => array(
        'visible' => array(
          ':input[name="project[settings][github][pull_request_environments]"]' => array('checked' => TRUE),
        ),
      ),
  );

  // Pull Request Environment method.
  // $form['github']['pull_request_environments_method'] = array(

  $options = array(
    t('Install Drupal') => array(
        'devshop__github__install' => empty($node->project->install_profile)? t('Default Install Profile (configured later)'): $node->project->install_profile,
    ),
    t('Clone another environment') => array(),
  );

  $options[t('Clone another environment')] = $form_state['environments'];
  $options[t('Clone another environment')]['_primary'] = t('Primary Environment');

  if (empty($options[t('Clone another environment')])) {
    $options[t('Clone another environment')]['_primary'] = t('Primary Environment (configured later)');
  }

  $form['project']['settings']['github']['pull_request_environments_method'] = array(
      '#type' => 'select',
      '#title' => t('Site Installation Method'),
      '#default_value' => isset($node->project->settings->github) ?
          $node->project->settings->github['pull_request_environments_method'] : 'devshop__github__install',
      '#description' => t('Select the method for installing the Pull Request environments.'),
      '#options' => $options,
      '#states' => array(
        'visible' => array(
          ':input[name="project[settings][github][pull_request_environments]"]' => array('checked' => TRUE),
        ),
      ),
  );
  $form['project']['settings']['github']['pull_request_reinstall'] = array(
    '#type' => 'checkbox',
    '#title' => t('Rebuild Pull Request Environments on every git push. <div class="help-block">Destroy and Rebuild Pull Request environments on every code push. All data in environments created via Pull Request will be destroyed every time code is pushed. The rebuild method is determie</div>'),
    '#default_value' => isset($node->project->settings->github) ?
      $node->project->settings->github['pull_request_reinstall'] : 0,
    '#states' => array(
      'visible' => array(
        ':input[name="project[settings][github][pull_request_environments]"]' => array('checked' => TRUE),
      ),
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter() for site_node_form().
 *
 * Add the list of PRs to the Branch selector.
 */
function devshop_github_form_site_node_form_alter(&$form, &$form_state, $form_id) {

  $project = $form_state['project'];
  if (arg(1) == 'add' && $project->git_provider == 'github'){
    $prs = devshop_github_client()->pullRequests()->all($project->github_owner, $project->github_repo);

    if (count($prs)) {
      $existing_options = $form['git_ref']['#options'];
      foreach ($prs as $pr) {
        $pr_description = implode(' - ', array(
          "PR {$pr['number']}",
          $pr['head']['ref'],
          $pr['user']['login'],
          $pr['title'],
        ));
        $option_name = $pr['head']['ref'];
        $pr_options['Pull Requests'][$option_name] = $pr_description;
        $form_state['pull_requests'][$option_name] = $pr;
      }

      $form['git_ref']['#title'] = t('Branch, Tag, or Pull Request');

    }

    $form['git_ref']['#options'] = array_merge($pr_options, $existing_options);
    $form['git_ref']['#element_validate'] = array(
      'devshop_github_form_site_node_form_validate_pr'
    );
  }
}

/**
 * @param $element
 * @param $form_state
 */
function devshop_github_form_site_node_form_validate_pr($element, &$form_state, $form)
{
  // If PR found for this branch, put the PR data into form_state.
  if (!empty($form_state['pull_requests'][$element['#value']])) {
    $form_state['values']['pull_request'] = $pr = convert_to_object($form_state['pull_requests'][$element['#value']]);

    // If PR has different remote URL, set it.
    if ($pr->head->repo->fork) {
      // Try to match project URL scheme
      if (strpos($form_state['project']->git_url, 'https://') === 0) {
        $remote_url = $pr->head->repo->clone_url;
      }
      elseif (strpos($form_state['project']->git_url, 'git://') === 0){
        $remote_url = $pr->head->repo->git_url;
      }
      elseif (strpos($form_state['project']->git_url, 'git@') === 0){
        $remote_url = $pr->head->repo->ssh_url;
      }
      else {
        $remote_url = $pr->head->repo->clone_url;
      }

      // Set repo_url for this environment to the forked git remote.
      form_set_value($form['git']['repo_url'], $remote_url, $form_state);

      // Recreate the platform node, with the new git repo_url.
      $platform_node = devshop_prepare_platform_node($form_state['project'], $form_state['environment_name'], $form_state['values']['git_ref'], $form_state['values']['web_server'], $form_state['values']['git']['repo_url']);
      form_set_value($form['platform_node'], $platform_node, $form_state);
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function devshop_github_node_insert($node) {
  if ($node->type == 'site' && !empty($node->pull_request)) {
    $environment = new stdClass();
    $environment->name = $node->environment_name;
    $environment->project_nid = $node->project_nid;
    devshop_github_save_pr_env_data($node->pull_request, $environment);
  }

  // When a project is inserted, if the PR create policy is set to "all", create all PR environments.
//  if ($node->type == 'project' && $node->project->settings['github']['pull_request_create_policy'] == 'all') {

    // No errors, but this doesn't work.
//    // Ensure github owner and repo are set.
//    if (empty($node->project->github_owner)) {
//      $git_repo_url = strtr($node->project->git_url, array(
//        'git@github.com:' => 'http://github.com/',
//        'git://' => 'http://',
//        '.git' => '',
//      ));
//      $parts = explode('/', parse_url($git_repo_url, PHP_URL_PATH));
//      $node->project->github_owner = $parts[1];
//      $node->project->github_repo = $parts[2];
//    }
//
//    devshop_github_create_all_pr_environments($node);
//  }
}

/**
 * Helper to normalize arrays to objects.
 *
 * @param $array
 * @return mixed
 */
function convert_to_object($thing) {
  $yml = Yaml::dump($thing, 2, 2, Yaml::DUMP_OBJECT_AS_MAP);
  $object = Yaml::parse($yml, Yaml::PARSE_OBJECT_FOR_MAP);
  return $object;
}

/**
 * Implements hook_form_alter().
 */
function devshop_github_form_devshop_project_create_step_git_alter(&$form, &$form_state, $form_id) {

  module_load_include('inc', 'devshop_github', 'includes/admin');

  if (!devshop_github_check_key(TRUE)) {

    drupal_set_message( '<p class="alert text-center"><i class="fa fa-exclamation-circle"></i> ' . t('DevShop GitHub Integration is not set up. You should complete setup on the Settings page before continuing.') . '</p><p class="alert text-center">' .  l( '<i class="fa fa-github"></i> ' . t('DevShop GitHub Settings'),'admin/devshop/github', array(
      'html' => TRUE,
      'attributes' => array(
        'class' => array('btn btn-default text-center'),
      ))) .'</p>' , 'warning');
  }
  else {
    $form['connect'] = array();
  }

  $repos = variable_get('devshop_github_available_repositories', array());
  foreach ($repos as $repo_name => $repo) {
    $options[$repo['org']][$repo['url']] = $repo_name;
  }

  if (count($options) && empty($form['source']['git_url']['#default_value'])) {
    $form['source']['git_source']['#default_value'] = 'github_existing';
  }

  unset($form['source']['git_source']['#options']['custom']);
  $form['source']['git_source']['#options']['custom'] = t('Custom Git repository URL');

  if (empty($options)) {
    $form['source']['github_repos'] = array(
      '#title' => t('Use an existing GitHub repository'),
      '#description' => t('No GitHub repositories found. !link', array(
        '!link' => l(t('Refresh GitHub Repos'), 'admin/devshop/github/load-repos', array(
          'query' => drupal_get_destination(),
          'attributes' => array(
            'class' => array('btn btn-primary'),
          ),
        )))),
      '#type' => 'item',
      '#states' => array(
        'visible' => array(
          ':input[name="git_source"]' => array(
            'value' => 'github_existing'
          ),
        ),
      ),
    );
  }
  else {

  $form['source']['github_repos'] = array(
    '#title' => t('Use an existing GitHub repository'),
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => $form['source']['git_url']['#default_value'],
    '#description' => t('Select the GitHub repository to use for this project. Remember, it must contain a Drupal site.') . ' ' .  l(t('Refresh GitHub Repos List'), 'admin/devshop/github/load-repos', array('query' => drupal_get_destination())),
    '#bootstrap_ignore_pre_render' => TRUE,
    '#states' => array(
      'visible' => array(
        ':input[name="git_source"]' => array(
          'value' => 'github_existing'
        ),
      ),
    ),
  );

  }
  $form['source']['github_create'] = array(
    '#type' => 'container',
    '#tree' => TRUE,
    '#attributes' => array(
      'class' => array(
        'form-group'
      ),
    ),
    '#states' => array(
      'visible' => array(
        ':input[name="git_source"]' => array(
          'value' => 'github_create'
        ),
      ),
    ),
    '#parents' => array(
      'github_create',
    ),

  );

  try {
    $client = devshop_github_client();
    $account = $client->currentUser()->show();
    $repo_owners = variable_get('devshop_github_available_organizations', array('' => t('You do not have repository create permissions for any organizations.')));
    $repo_owners[$account['login']] = $account['login'];

    asort($repo_owners);
    $form['source']['github_create']['github_organization'] = array(
      '#type' => 'select',
      '#title' => t('Create a new GitHub repository'),
      '#options' => $repo_owners,
      '#bootstrap_ignore_pre_render' => TRUE,
      '#attributes' => array(
        'class' => array(
          'form-control form-inline'
        ),
      ),
    );
    $form['source']['github_create']['github_repository_name'] = array(
      '#type' => 'textfield',
      '#attributes' => array(
        'placeholder' => t('repo_name'),
        'class' => array('form-inline'),
      ),
      '#element_validate' => array(
        'devshop_github_create_repository'
      ),
    );
    $form['source']['github_create']['github_repository_public'] = array(
      '#type' => 'radios',
      '#options' => array(
        1 => t('Public: Anyone can see this repository. You choose who can commit.'),
        0 => t('Private: You choose who can see and commit to this repository.')
      ),
      '#default_value' => 1,
    );
  }
  catch (\Exception $e) {
    // We've already got a message.
    //    drupal_set_message($e->getMessage(), 'warning');
  }

  $form['source']['settings']['#weight'] = 1;
  $form['source']['settings']['#tree'] = 1;
  $form['github_repository_source'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array(
        'well'
      ),
    ),
    '#states' => array(
      'visible' => array(
        ':input[name="git_source"]' => array(
          'value' => 'github_create'
        ),
      ),
    ),
    '#tree' => 1,
    '#parents' => array(
      'settings',
      'github_repository_source',
    ),
  );


  $form['github_repository_source']['populate_choice'] = array(
//    '#prefix' => '<div class="well">',
    '#type' => 'radios',
    '#default_value' => 'create',
    '#title' => t('Choose what to put into your new Git repository'),
    '#options' => array(
      'create' => t('Create project using composer'),
      'import' => t('Import from another Git URL'),
    ),
  );

  $suggested_repos = variable_get('devshop_git_repo_suggestions', array(
    'git@github.com:opendevshop/devshop-composer-template.git',
  ));
  $options = array_combine(array_values($suggested_repos),array_values($suggested_repos));
  $options['custom'] = t('Enter a custom Git URL');

  $form['github_repository_source']['import'] = array(
    '#type' => 'textfield',
    '#attributes' => array(
      'placeholder' => t('git@githost.com:example/repo.git'),
    ),
    '#description' => t('Your new repo will be a clone of this repository on the default branch.') .' ' . l(t('Suggested Repos'), '', array(
      'attributes' => array(
        'class' => array('put-back-suggested-repos'),
      ),
    )),
    '#states' => array(
      'visible' => array(
        ':input[name="settings[github_repository_source][populate_choice]"]' => array(
          'value' => 'import'
        ),
        'select[name="settings[github_repository_source][import_suggestions]"]' => array(
          'value' => 'custom'
        ),
      ),
    ),
    '#element_validate' => array(
      'devshop_github_set_import_url'
    ),
  );

  $form['github_repository_source']['import_suggestions'] = array(
    '#type' => 'select',
    '#options' => $options,
    '#description' => t('Your new repo will be a direct clone of this repository. All commits will be loaded into the new repository.'),
    '#states' => array(
      'visible' => array(
        ':input[name="settings[github_repository_source][populate_choice]"]' => array(
          'value' => 'import'
        ),
        'select[name="settings[github_repository_source][import_suggestions]"]' => array(
          '!value' => 'custom'
        ),
      ),
    ),
  );


  $suggested_projects = variable_get('devshop_composer_project_suggestions', array(
    'devshop/composer-template:8.x-dev',
    'devshop/composer-template:7.x-dev',
//    'acquia/lightning-project',
  ));

  $options = array_combine(array_values($suggested_projects),array_values($suggested_projects));
  $options['custom'] = t('Enter custom project');

  $form['github_repository_source']['composer_project_suggestions'] = array(
    '#type' => 'select',
    '#options' => $options,
    '#description' => t('The command above will be run and all the resulting files will be committed to your repository.'),
    '#field_prefix' => '<div class="input-group"><code class="input-group-addon">composer create-project </code>',
    '#field_suffix' => '<code class="input-group-addon input-group-addon-url">' . t('projectname') .'</code>
        </div>',
    '#states' => array(
      'visible' => array(
        ':input[name="settings[github_repository_source][populate_choice]"]' => array(
          'value' => 'create'
        ),
        'select[name="settings[github_repository_source][composer_project_suggestions]"]' => array(
          '!value' => 'custom'
        ),
      ),
    ),
  );

  $form['github_repository_source']['composer_project'] = array(
    '#type' => 'textfield',
    '#description' => t('The command above will be run and all the resulting files will be committed to your repository.') . ' ' . l(t('Suggested Projects'), '', array(
      'attributes' => array(
        'class' => array('put-back-suggested-projects'),
      ),
    )),
    '#field_prefix' => '<div class="input-group"><code class="input-group-addon">composer create-project </code>',
    '#field_suffix' => '<code class="input-group-addon input-group-addon-url"> ' . t('projectname') .'</code>
        </div>',
//    '#default_value' => $suggested_projects[0],
    '#attributes' => array(
      'placeholder' => $suggested_projects[0],
    ),
    '#states' => array(
      'visible' => array(
        ':input[name="settings[github_repository_source][populate_choice]"]' => array(
          'value' => 'create'
        ),
        'select[name="settings[github_repository_source][composer_project_suggestions]"]' => array(
          'value' => 'custom'
        ),
      ),
    ),
    '#element_validate' => array(
      'devshop_github_set_composer_project'
    ),
  );

  $form['github_repository_source']['wrapper'] = array(
    '#markup' => drupal_valid_path('admin/devshop')? l(t("Modify suggested projects in DevShop Settings"), 'admin/devshop'): '',
//    '#suffix' => '</div>',
  );

  $form['source']['git_url']['#required'] = FALSE;
  $form['source']['git_url']['#element_validate'] = array(
    'devshop_github_create_project_form_set_values'
  );

  // We have to tell the front-end what type of field so we can assign the right event.
  drupal_add_js(array(
    'devshop' => array(
      'projectNameSourceElements' => array(
        '#edit-github-repos',
        '#edit-github-create-github-repository-name',
      ),
    ),
  ), 'setting');

}

/**
 * Implements hook_devshop_project_git_repo_options().
 */
function devshop_github_devshop_project_git_repo_options() {
  return array(
    'github_existing' => t('Use an existing GitHub repository'),
    'github_create' => t('Create a new GitHub repository'),
  );
}

/**
 * @param $element
 * @param $form_state
 * @param $form
 */
function devshop_github_create_project_form_set_values($element, &$form_state, &$form) {

  $form_state['values']['settings']['git_source'] = $form_state['values']['git_source'];

  if ($form_state['values']['git_source'] == 'github_existing') {
    form_set_value($element, $form_state['values']['github_repos'] , $form_state);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alters devshop_project_create_step_environments form.
 */
function devshop_github_form_devshop_project_create_step_environments_alter(&$form, &$form_state, $form_id) {

  $project = &$form_state['project'];
  $form['pr_environments'] = array(
    '#type' => 'container',
    '#prefix' => '<h3 class="title">' . t('Pull Request Environments') . '</h3>',
    '#weight' => -100,
  );
  $form['pr_environments']['environments_table'] = array(
    '#tree' => TRUE,
    '#theme' => 'devshop_projects_create_settings_form',
  );

  // Load the PRs.
  try{
    $prs = devshop_github_client()->pullRequests()->all($project->github_owner, $project->github_repo);

    foreach ($prs as $pr) {//    '#type' => 'fieldset',


      // Prepare environment objects
      $environment = new stdClass();
      $environment->name = "pr{$pr['number']}";
      $environment->git_ref = $pr['head']['ref'];
      $project->environments[$environment->name] = $environment;

      // Prepare form element.
      $element = devshop_project_environment_create_form_element($project, $environment);
      $element['name']['#attributes']['readonly'] = 1;
      $element['git_ref']['#type'] = 'value';
      $element['git_ref']['#value'] = $environment->git_ref;
      $element['git_ref']['git_ref_display'] = array(
        '#type' => 'markup',
        '#markup' => "<a href='{$pr['html_url']}' class='btn btn-link' target='_blank'><img src='{$pr['user']['avatar_url']}' width='32'> {$environment->git_ref}</a></code>",
      );

      // Only add to $form if configured to keep all environments.
      if ($project->settings->github['pull_request_create_policy'] == 'all') {
        $form['pr_environments']['environments_table'][$environment->name] = $element;
      }
    }

    // Push "new" to the bottom.
    $new_element = $form['project']['environments']['NEW'];
    unset($form['project']['environments']['NEW']);
    $form['project']['environments']['NEW'] = $new_element;

    $settings_link = l(t('Change Project Settings'), 'projects/add/settings', array(
      'fragment' => 'edit-project-settings-github',
    ));

    $prs_link = l(t('Pull Requests for @repo', array(
      '@repo' => $project->github_owner . '/' . $project->github_repo,
    )), $project->git_repo_url . '/pulls', array(
      'attributes' => array('target' => '_blank')
    ));

    // Project with PR environments disabled.
    if (!$project->settings->github['pull_request_environments']) {
      $help_display['help'] = array(
        '#theme' => 'item_list',
        '#items' => array(
          t('Pull Request environments are disabled for this project.'),
          $settings_link,
          $prs_link,
        ),
        '#prefix' => '<div class="alert alert-warning">',
        '#suffix' => '</div>',
      );
    }
    // Project configured to maintain all PR environments.
    elseif ($project->settings->github['pull_request_create_policy'] == 'all') {
      $help_display['help'] = array(
        '#theme' => 'item_list',
        '#items' => array(
          t('Project is configured to create environments for all Pull Requests.'),
          $settings_link,
          $prs_link,
        ),
        '#prefix' => '<div class="alert alert-info">',
        '#suffix' => '</div>',
      );
    }
    // Project configured to only create environments on PR open or re-open.
    elseif ($project->settings->github['pull_request_create_policy'] == 'create') {
      $help_display['help'] = array(
        '#theme' => 'item_list',
        '#items' => array(
          t('Project is configured to create environments only for new or reopened Pull Requests.'),
          $settings_link,
          $prs_link,
        ),
        '#prefix' => '<div class="alert alert-info">',
        '#suffix' => '</div>',
      );
    }
  }
  catch (\Exception $e) {
    $help_display['gh_error'] = array(
      '#theme' => 'item_list',
      '#items' => array(
        t('GitHub authentication failed. Check your token at !link. The error was: %message', array(
          '%message' => $e->getMessage(),
          '!link' => l('DevShop GitHub Settings', 'admin/devshop/github'),
        )),
        $settings_link,
      ),
      '#prefix' => '<div class="alert alert-danger">',
      '#suffix' => '</div>',
    );
  }
  $form['pr_environments']['help'] = $help_display;
  $form['pr_environments']['help']['#weight'] = -1;

  // Add a header to distinguish from PRs
  $form['project']['#prefix'] = '<h3 class="title">' . t('Create Additional Environments') . '</h3>';

}

/**
 * @param $element
 * @param $form_state
 * @param $form
 */
function devshop_github_set_import_url($element, &$form_state, &$form) {
  if ($form_state['values']['settings']['github_repository_source']['import_suggestions'] != 'custom') {
    form_set_value($element, $form_state['values']['settings']['github_repository_source']['import_suggestions'], $form_state);
  }
}

/**
 * @param $element
 * @param $form_state
 * @param $form
 */
function devshop_github_set_composer_project($element, &$form_state, &$form) {
  if ($form_state['values']['settings']['github_repository_source']['composer_project_suggestions'] != 'custom') {
    form_set_value($element, $form_state['values']['settings']['github_repository_source']['composer_project_suggestions'], $form_state);
  }
}

/**
 * Element validation for License Key. Pings devshop.support
 *
 * @param $element
 * @param $form_state
 * @param $form
 */
function devshop_github_create_repository($element, &$form_state, &$form) {

  if ($form_state['values']['git_source'] == 'github_create') {

    if (empty($element['#value'])) {
      form_error($element, t('You must enter a repository name.'));
    }
    else {
      $client = devshop_github_client();
      $name = $element['#value'];
      // Must be NULL if org is username.
      $organization = $form_state['values']['github_create']['github_organization'] == $client->currentUser()->show()['login']? NULL: $form_state['values']['github_create']['github_organization'];
      $public = $form_state['values']['github_create']['github_repository_public'];
      $description = t('Created by DevShop on @date', array('@date' => format_date(time())));

      try {
        $repo = $client->repos()->create($name,
          $description,
          '',
          $public,
          $organization
        );
        form_set_value($form['source']['git_url'], $repo['ssh_url'],$form_state);
        drupal_set_message(t('New GitHub Repository was created! See !link.', array(
          '!link' => l($repo['html_url'], $repo['html_url']),
        )));
      }
      catch (\Exception $e) {
        form_error($element, t('Unable to create repo. Error from GitHub: ') . $e->getMessage());
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for project_node_form().
 */
function devshop_github_form_devshop_project_create_step_sites_alter(&$form, &$form_state) {

  // Return if project isn't ready.
  if (empty($form['install_profile'])) {
    return;
  }

  // Return if there is no github token
  $github_token = variable_get('devshop_github_token', '');
  if (empty($github_token)) {
    return;
  }

  // Load project and github
  $project_node = node_load($form['nid']['#value']);
  $project = $project_node->project;

  // Return if provider is not github.
  if ($project->git_provider != 'github') {
    return;
  }

  // Return if deploy method is not webhook.
  if ($project->settings->deploy['method'] != 'webhook') {
    return;
  }

  $repo = $project->github_owner . '/' . $project->github_repo;
  $repo_url = "http://github.com/" . $repo;

  $form['github_webhook'] = array(
    '#title' => t('Setup GitHub Webhook'),
    '#description' => t('Leave this box checked to automatically add a webhook to your GitHub Repository !link.', array(
      '!link' => l($repo, $repo_url, array(
          'attributes' => array(
            'target' => '_blank',
          ),
      ))
    )),
    '#type' => 'checkbox',
    '#default_value' => 1,
  );

  $form['#validate'][] = 'devshop_github_project_create_webhook';
  $form['#submit'][] = 'devshop_github_project_create_webhook';
}

/**
 * Extra submit hook for last step of project create form.
 */
function devshop_github_project_create_webhook($form, $form_state) {

  // Return if box is not checked.
  if (empty($form_state['values']['github_webhook'])) {
    return;
  }

  // Get Project
  $project_node = node_load($form['nid']['#value']);
  $project = $project_node->project;

  // Get GitHub client
  $client = new Github\Client();
  $github_token = variable_get('devshop_github_token', '');
  $client->authenticate($github_token, Github\Client::AUTH_HTTP_TOKEN);

  // Create the webhook.
  try {
    $hook = $client->repo()->hooks()->create($project->github_owner, $project->github_repo, array(
        'name' => 'web',
        'active' => true,
        'events' => array(
            'push',
            'pull_request',
            'delete',
            'release',
        ),
        'config' => array(
            'url' => $project->webhook_url,
            'content_type' => 'json',
            'insecure_ssl' => '1',
        ),
    ));
  }
  catch (Github\Exception\ValidationFailedException $e) {
    if ($e->getMessage() == 'Validation Failed: Hook already exists on this repository') {
      // For some reason, github always throws this exception on hooks()->create, but the webook still gets created!!

      //      drupal_set_message(t("GitHub webhook added, but there is already an existing webhook. Please check your repository's !link.", array(
//          '!link' => l(t('Webhook Settings'), $project->git_repo_url . '/settings/hooks'),
//      )), 'warning');
    }
    else {
      drupal_set_message(t('GitHub Validation Exception: !exception', array('!exception' => $e->getMessage())), 'error');
    }
  }
  catch (Github\Exception\RuntimeException $e) {
    drupal_set_message(t('GitHub Runtime Exception: !exception', array('!exception' => $e->getMessage())), 'error');
  }
}

/**
 * Implements hook_node_load().
 */
function devshop_github_node_load($nodes, $types) {
  if (count(array_intersect(array('project'), $types))) {
    foreach ($nodes as $nid => $node) {

      // Look for a pull request object.
      $pull_requests = db_query('SELECT * FROM {hosting_devshop_github_pull_requests} WHERE project_nid = :project_nid', array(':project_nid' => $nid));
      foreach ($pull_requests as $pull_request) {
        if (!empty($pull_request->pull_request_object)) {
          $pull_request->pull_request_object = unserialize($pull_request->pull_request_object);
          if (isset($node->project->environments[$pull_request->environment_name])) {
            $node->project->environments[$pull_request->environment_name]->github_pull_request = $pull_request;
          }
        }
      }

      // Parse github owner and repo.
      if (isset($node->project) && $node->project->git_provider == 'github') {
        $node->project->github_owner =
          $parts = explode('/', parse_url($node->project->git_repo_url, PHP_URL_PATH));
        $node->project->github_owner = $parts[1];
        $node->project->github_repo = $parts[2];
      }
    }
  }

}

/**
 * Implements hook_node_update() for task insert.
 *
 * If task is a test run, send a "pending" commit status.
 */
function devshop_github_node_update($node) {

  // Only act on test triggers.
  if ($node->type != 'task' || $node->type == 'task' && ($node->task_type != 'test' || $node->task_type != 'deploy')) {
    return;
  }

  // Load the site and check for environment.
  $site = node_load($node->rid);
  if (empty($site->environment) || empty($site->environment->github_pull_request) || empty($site->environment->settings->deploy['test'])) {
    return;
  }

  try {
    $token = variable_get('devshop_github_token', '');
    $client = new \Github\Client();
    $client->authenticate($token, Github\Client::AUTH_HTTP_TOKEN);

    // Create a deployment status
    $project = $site->project;
    $owner = $project->github_owner;
    $repo = $project->github_repo;
    $sha = $site->environment->github_pull_request->pull_request_object->head->sha;

    $params = new stdClass();
    $params->state = 'pending';

    if ($node->task_type != 'test') {
      $params->target_url = url(
        "node/{$node->nid}",
        array('absolute' => true)
      );
      $params->description = t('DevShop: Run Tests');
      $params->context = "devshop/{$project->name}/tests";
    }
    elseif ($node->task_type != 'deploy') {
      $params->target_url = $site->environment->url;
      $params->description = t('DevShop: Deploy');
      $params->context = "devshop/{$project->name}/deploy";
    }

    // Post status to github
    $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));

    watchdog('devshop_github','Test run initiated. GitHub has been notified.');
  } catch (Github\Exception\RuntimeException $e) {
    watchdog('devshop_github', 'GitHub Runtime Error in devshop_github_node_update(): ' . $e->getMessage());
  }
}


/**
* Implements hook_hosting_task_update_status()
*/
// function devshop_github_hosting_task_update_status($task, $status) {
//
//  $task_types = array(
//    'test',
//    'import',
//    'devshop-deploy',
//  );
//
//  if (in_array($task->task_type, $task_types) && $task->ref->type == 'site' && isset($task->ref->environment->github_pull_request)) {
//
//    // If autoloader is not available, return.
//    if (!file_exists(__DIR__ . '/vendor/autoload.php')) {
//      return;
//    }
//
//    // If project is not from github, return.
//    if ($task->ref->project->git_provider != 'github') {
//      return;
//    }
//
//    // Include vendors
//    require_once 'vendor/autoload.php';
//
//    drush_log('===========================================', 'ok');
//    drush_log('Notifying github...', 'ok');
//
//    // Extract username and repo
//    list($s, $owner, $repo) = explode('/', parse_url($task->ref->project->git_repo_url, PHP_URL_PATH));
//
//    try {
//      $token = variable_get('devshop_github_token', '');
//      $client = new \Github\Client();
//      $client->authenticate($token, Github\Client::AUTH_HTTP_TOKEN);
//
//      // Create a status
//      $sha = $task->ref->environment->github_pull_request->pull_request_object->head->sha;
//
//      if ($task->task_type == 'devshop-deploy'){
//        $description = t('Deployed to Environment: ') . _hosting_parse_error_code($status);
//        $url = $task->ref->environment->url;
//      }
//      elseif ($task->task_type == 'test') {
//        $description = t('Tests: ') . _hosting_parse_error_code($status);
//        $url = url("devshop_tests/{$task->nid}/{$task->vid}", array('absolute' => TRUE));
//      }
//      else {
//        $description = 'Something happened...';
//        $url = $task->ref->environment->url;
//      }
//
//      if ($status == HOSTING_TASK_ERROR) {
//        $state = 'error';
//      }
//      elseif ($status == HOSTING_TASK_PROCESSING) {
//        $state = 'pending';
//      }
//      elseif ($status == HOSTING_TASK_SUCCESS || $status == HOSTING_TASK_WARNING) {
//        $state = 'success';
//      }
//      else {
//        $state = 'error';
//      }
//
//      $params = new stdClass();
//      $params->state = $state;
//      $params->target_url = $url;
//      $params->description = $description;
//      $params->context = 'devshop/' . $task->task_type;
//
//      $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
//
//      drush_log('Status posted! ', 'ok');
//    } catch (Github\Exception\RuntimeException $e) {
//      drush_log('GitHub API Error: ' . $e->getMessage(), 'error');
//      drush_log(l(t('Configure GitHub API'), 'admin/devshop/github'), 'error');
//    } catch (Github\Exception\ValidationFailedException $e) {
//      drush_log('GitHub API Error: ' . $e->getMessage(), 'error');
//    }
//
//    drush_log('done trying... ', 'ok');
//
//  }
// }

/**
 *
 */
function devshop_github_comment($task, $status) {

  $output = array();
  $output[] = '> **DEVSHOP**';
  $output[] = '> ' . ucfirst($task->task_type) .  ": " . _hosting_parse_error_code($status);
  $output[] = '> Site: ' . $task->ref->environment->url;
  $output[] = '> Project: ' . url("node/{$task->ref->project->nid}", array('absolute' => TRUE));

  if ($task->task_type == 'test') {
    $output[] = 'Results: ' . url("node/{$task->nid}", array('absolute' => TRUE));
  }

  if ($task->task_type == 'import') {
    $output[] = t('Your environment is now available.');
  }

  return implode("\n", $output);
}



/**
 * GitHub action to take on webhook init
 */
function devshop_github_webhook($project_node) {
  $headers = getallheaders();
  $project = $project_node->project;

  // @TODO: Handle form content from github as well.
  if ($headers['Content-Type'] == 'application/json' || $headers['content-type'] == 'application/json') {
    $data = json_decode(file_get_contents('php://input'));

    $args = array();
    $args['cache'] = 1;

    if (isset($headers['X-Github-Event'])) {
      $github_event = $headers['X-Github-Event'];
    }
    elseif (isset($headers['X-GitHub-Event'])) {
      $github_event = $headers['X-GitHub-Event'];
    }
    else {
      $github_event = '';
    }

    switch ($github_event) {
      case 'ping':
        $message = 'Pong!';
        break;
      case 'push':

        // If push is for a deleted branch, don't do anything.
        if ($data->deleted && $data->after == "0000000000000000000000000000000000000000") {
          $message = 'Deleted ref detected.';
          break;
        }

        // Limit "Deploy" tasks to only run for the branches we have new code for..
        $git_ref = strtr($data->ref, array('refs/tags/' => '', 'refs/heads/' => ''));

        // Check for environments set to pull
        $environments_to_pull = array();
        $message = "Push Received for git ref $git_ref.";

        foreach ($project->environments as $environment_name => $environment) {

          // Only pull if deploy is not disabled or if environment is tracking a tag.
          if (
//            @TODO: Improve this. If a site install failed, it shows up as "disabled", so we should still do a git pull.
            $git_ref == $environment->git_ref &&
            !$environment->settings->pull_disabled &&
            !in_array($environment->git_ref, $project->settings->git['tags'])
          ) {
            $environments_to_pull[] = $environment->name;

            if (isset($environment->site) && $node = node_load($environment->site)) {

              // If project is set to reinstall pull request environments, and this is a pull request environment, run a forced install task.
              if (isset($project->settings->github['pull_request_reinstall']) && $project->settings->github['pull_request_reinstall'] && isset($environment->github_pull_request)) {

                // Trigger deploy task to get latest code.
                // Pass no args to skip DB updates, cache clearing, etc.
                hosting_add_task($environment->site, 'devshop-deploy', array(
                  'git_ref' => $environment->git_ref,
                ));

                // Trigger "install" with force-reinstall
                hosting_add_task($environment->site, 'install', array('force-reinstall' => 1));
              }

              // Otherwise, just run a "deploy" task.
              else {

                // Default args to the environments deploy settings.
                $args = $environment->settings->deploy;
                $args['git_ref'] = $environment->git_ref;
                hosting_add_task($environment->site, 'devshop-deploy', $args);
              }
            }
          }
        }

        if (empty($environments_to_pull)) {
          $message .= "No environments tracking this branch. ";
        }
        else {
          $message .= "Deploying code to environments: " . implode(', ', $environments_to_pull);
        }
        break;

      case 'pull_request':
        // If pull request environments is enabled...
        if ($project->settings->github['pull_request_environments']) {
          $message = 'Pull Request Received.';

          // @TODO: Handle forks?
          $branch = $data->pull_request->head->ref;

          // Determine environment branch.
          // @TODO: Make Configurable, allow branch names to be env name
          $environment_name = "pr" . $data->pull_request->number;
//          $environment_name = 'branch_' . str_replace('-', '_', $branch);
          $already_have_pr_info = FALSE;

          // When PR is opened... create new environment.
          if ($data->action == 'opened' || $data->action == 'reopened') {
            $message = "Detected Pull Request creation for $branch \n";
            if (isset($project->environments[$environment_name])) {
              $message = "Environment $environment_name already exists! Not creating one... \n";

              // @TODO: Check for environments that are being deleted.
              if (isset($project->environments[$environment_name]->github_pull_request)) {
                $message .= "Already have a PR for $environment_name ... not inserting.";
                $already_have_pr_info = TRUE;
              }
            }
            else {
              // If method is "install"...
              if ($project->settings->github['pull_request_environments_method'] == 'devshop__github__install') {
                hosting_create_environment($project, $environment_name, $branch);
                $message .= "Environment $environment_name created for $project_node->title via installation profile.\n";
              }
              // Otherwise, it is a clone from live.
              elseif (isset($project->environments[$project->settings->github['pull_request_environments_method']] )) {
                $source_env = $project->settings->github['pull_request_environments_method'];
                hosting_create_environment($project, $environment_name, $branch, $source_env);
                $message .= "Environment $environment_name created for $project_node->title via cloning $source_env \n";
              }
              else {
                $message .= 'Unable to determine what to do! Check "Pull Request Environment Method" setting.';
              }
            }

            $project_node = node_load($project->nid);
            $project = $project_node->project;
            $environment = $project->environments[$environment_name];

            $owner = $project->github_owner;
            $repo = $project->github_repo;
            $message .= "\n About to try to create a deployment for $owner/$repo...  \n";

            // Send a "deployment" to github.
            try {
              $token = variable_get('devshop_github_token', '');
              $client = new \Github\Client();
              $client->authenticate($token, Github\Client::AUTH_HTTP_TOKEN);

              $sha = $data->pull_request->head->sha;

              $params = new stdClass();
              $params->ref = $sha;

              // In GitHub's API, "environment" is just a small string it displays on the pull request:
              $params->environment = $project->name . '.' . $environment_name;
                devshop_environment_url($project, $environment_name)
              ;
              $params->required_contexts = array();

              // $message .= "\nEnvironment: " . print_r($environment, 1);
              $message .= "\nDeployment Params: " . print_r($params, 1);

              $post_url = "/repos/$owner/$repo/deployments";
              $deployment = json_decode($client->getHttpClient()->post($post_url, json_encode($params))->getBody(TRUE));

              // Save deployment to pull request data for later access.
              $data->pull_request->deployment = $deployment;

              $message .= " Deployment Created! \n";

              // Create deployment status
              $params = new stdClass();
              $params->state = 'pending';
              $params->target_url = $environment->url;;
              $params->description = t('New environment is being created.  Please stand by.');
              $deployment_status = $client->getHttpClient()->post("/repos/$owner/$repo/deployments/{$deployment->id}/statuses", json_encode($params));

              $message .= " Deployment Status Created! \n";

              // Set a commit status for this REF for devshop/deploy context
              $sha = $data->pull_request->head->sha;

              $params = new stdClass();
              $params->state = 'pending';
              $params->target_url = url("node/$environment->site", array('absolute' => TRUE));
              $params->description = t('DevShop: Deploy');
              $params->context = "devshop/{$project->name}/deploy";

              // Post status to github
              $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
              $message .= " Commit Status Created! \n";

              // Determine if we are going to run tests.
              // For now it is using the "live environment" setting.
              // @TODO: Once we add "deploy hooks" to "Project Settings: Environment Defaults" we will have to change this.

//              // If live environment is set to run tests on deploy...
//              $live_environment = $project->settings->live['live_environment'];
//              if ($project->environments[$live_environment]->settings->deploy['test']) {
//                $params = new stdClass();
//                $params->state = 'pending';
//                $params->target_url = url(
//                  "node/$environment->site",
//                  array('absolute' => true)
//                );
//                $params->description = t('DevShop: Run Tests');
//                $params->context = 'devshop/tests';
//
//                // Post status to github
//                $status = $client->getHttpClient()->post(
//                  "/repos/$owner/$repo/statuses/$sha",
//                  json_encode($params)
//                );
//                $message .= " Commit Status for pending test run Created! \n";
//              }

            } catch (Github\Exception\RuntimeException $e) {
              watchdog('devshop_github', 'GitHub Runtime Error: ' . $e->getMessage());
              $message .= 'GitHub RunTimeException during PR Create: ' . $e->getMessage() . $e->getCode();

              if ($e->getCode() == '409') {
                $message .= "\n Branch is out of date! alert the developer!";

                // Send a failed commit status to alert to developer
                $params = new stdClass();
                $params->state = 'failure';
                $params->target_url = $project->git_repo_url;
                $params->description = t('Branch is out of date! Merge from default branch.');
                $params->context = "devshop/{$project->name}/merge";

                // Post status to github
                $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
              }
              else {
                http_response_code(500);
              }

            } catch (Github\Exception\ValidationFailedException $e) {
              watchdog('devshop_github', 'GitHub Validation Failed Error: ' . $e->getMessage());
              $message .= 'GitHub ValidationFailedException Error: ' . $e->getMessage();
            }

            // Insert PR record
            if (!$already_have_pr_info) {
              if (devshop_github_save_pr_env_data($data->pull_request, $project)) {
                $message .= ' ' . t('Pull Request info saved to DevShop.');
              }
              else {
                $message .= 'Saving PR record failed: ' . $e->getMessage();
              }

//              $info = new stdClass();
//              $info->id = $data->pull_request->id;
//              $info->number = $data->pull_request->number;
//              $info->project_nid = $project->nid;
//              $info->environment_name = $environment_name;
//              $info->pull_request_object = serialize($data->pull_request);
//
//              // Last minute check for existing PR info
//              $results = db_select('hosting_devshop_github_pull_requests', 'pr')
//                ->condition('id', $data->pull_request->id)
//                ->fields('pr', array('id'))
//                ->execute()
//                ->fetchAssoc();
//
//              // If there are results, save $update param for drupal_write_record().
//              if (empty($results)) {
//                $update = array();
//              }
//              else {
//                $update = array('id');
//              }
//
//              // Save environment record.
//              try {
//                drupal_write_record('hosting_devshop_github_pull_requests', $info, $update);
//                $message .= ' ' . t('Pull Request info saved to DevShop.');
//              }
//              catch (\PDOException $e) {
//                $message .= 'Saving PR record failed: ' . $e->getMessage();
//              }
            }
          }

          // When PR is updated, send a new deployment status environment.
          elseif ($data->action == 'synchronize') {

            // Create a new deployment
            $owner = $project->github_owner;
            $repo = $project->github_repo;
            $environment = $project->environments[$environment_name];

            // Environment might have been deleted.
            if (empty($environment)) {
              $message .= "Environment $environment_name not found in project $project->name.";
              continue;
            }

            $message .= "About to set deployment status for repo $owner/$repo using environment $environment_name  \n";
            $message .= "Environment: " . print_r($environment, 1);

            try {
              $token = variable_get('devshop_github_token', '');
              $client = new \Github\Client();
              $client->authenticate($token, Github\Client::AUTH_HTTP_TOKEN);

              $sha = $data->pull_request->head->sha;

              $params = new stdClass();
              $params->ref = $sha;
              $params->environment = $environment->url;
              $params->required_contexts = array();
              $post_url = "/repos/$owner/$repo/deployments";
              $deployment = json_decode($client->getHttpClient()->post($post_url, json_encode($params))->getBody(TRUE));

              // Save deployment to pull request data for later access.
              $data->pull_request->deployment = $deployment;

              $message .= " Deployment Created! \n";

              // Create deployment status
              $deployment_id = $deployment->id;

              $params = new stdClass();
              $params->state = 'pending';
              $params->target_url = $environment->url;
              $params->description = t('Code is being deployed.  Please stand by.');

              $post_url = "/repos/$owner/$repo/deployments/{$deployment_id}/statuses";
              $message .= "Attempting to create deployment status: $post_url \n";

              $deployment_status = $client->getHttpClient()->post($post_url, json_encode($params));

              $message .= " Deployment Status Created! \n";

              // Set a commit status for this REF for devshop/deploy context
              $sha = $data->pull_request->head->sha;

              $params = new stdClass();
              $params->state = 'pending';
              $params->target_url = url("node/$project->nid", array('absolute' => TRUE));
              $params->description = t('DevShop: Deploy');
              $params->context = "devshop/{$project->name}/deploy";

              // Post status to github
              $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));

              $message .= " Commit Status Created! \n";

              // If environment is configured to run tests, add another status.
              if (!empty($environment->settings->deploy['test'])) {
                $params = new stdClass();
                $params->state = 'pending';

                // @TODO: Add the link to the last "test" task here instead of the project.
                $params->target_url = url("node/$project->nid", array('absolute' => TRUE));
                $params->description = t('DevShop: Run Tests');
                $params->context = "devshop/{$project->name}/tests";

                // Post status to github
                $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));

                $message .= " Commit Status Created for test runs! \n";
              }

            } catch (Github\Exception\RuntimeException $e) {
              $log = 'GitHub API Error during PR Syncronize: ' . $e->getMessage() . $e->getCode();
              watchdog('devshop_github', $log);

              if ($e->getCode() == '409') {
                $log .= "\n Out of date! alert the developer!";

                // Send a failed commit status to alert to developer
                $params = new stdClass();
                $params->state = 'failure';
                $params->target_url = $project->git_repo_url;
                $params->description = t('Branch is out of date! Merge from default branch.');
                $params->context = "devshop/{$project->name}/merge";

                // Post status to github
                $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
              }
              else {
                http_response_code(500);
              }
              $message .= $log . "\n";
            }


            // Update the PR record
            $info = new stdClass();
            $info->id = $data->pull_request->id;
            $info->number = $data->pull_request->number;
            $info->project_nid = $project->nid;
            $info->environment_name = $environment_name;
            $info->pull_request_object = serialize($data->pull_request);

            // Save environment record.
            $results = db_select('hosting_devshop_github_pull_requests', 'pr')
              ->condition('id', $data->pull_request->id)
              ->fields('pr', array('id'))
              ->execute()
              ->fetchAssoc();

            // If there are results, save $update param for drupal_write_record().
            if (empty($results)) {
              $update = array();
            }
            else {
              $update = array('id');
            }

            // Save environment record.
            try {
              drupal_write_record('hosting_devshop_github_pull_requests', $info, $update);
              $message .= ' ' . t('Pull Request info saved to DevShop.');
            }
            catch (\PDOException $e) {
              $message .= 'Saving PR record failed: ' . $e->getMessage();
            }
          }
          // When PR is closed, delete environment.
          elseif ($data->action == 'closed') {
            $message .= "Pull Request Closed \n";
            if ($project->settings->github['pull_request_environments_delete']) {

              // If environment has a site... trigger it's deletion.
              // Platform deletion triggers after site deletion completes.
              if ($project->environments[$environment_name]->site) {
                hosting_add_task($project->environments[$environment_name]->site, 'delete', array('force' => 1));
                $message .= "Environment $environment_name (Site Node: {$project->environments[$environment_name]->site}) scheduled for deletion.";
              }
              // If environment has a platform... trigger it's deletion.
              elseif ($project->environments[$environment_name]->platform) {
                hosting_add_task($project->environments[$environment_name]->platform, 'delete');
                $message .= "Environment $environment_name (Platform Node: {$project->environments[$environment_name]->platform}) scheduled for deletion.";
              }
            }
          }
        }
        break;
    }

  }
  else {
    $message = 'GitHub Request Received, but not in JSON. Please make sure to configure the webhook to use Payload version: application/vnd.github.v3+json';
  }
  return $message;
}

/**
 * Check the GitHub account for an SSH key.
 *
 * @return bool
 */
function devshop_github_check_key($silent = false) {

  if (!devshop_public_key_valid_fingerprint()) {
    return FALSE;
  }

  $token = variable_get('devshop_github_token', '');
  if (empty($token)) {
    return FALSE;
  }

  $client = new \Github\Client();
  $client->authenticate($token, Github\Client::AUTH_HTTP_TOKEN);

  try {
    $keys = $client->currentUser()->keys()->all();
  }
  catch (Exception $e) {
    if (!$silent) {
      drupal_set_message($e->getMessage(), 'error');
    }
    return FALSE;
  }
  foreach ($keys as $key) {
    $ssh_key = sshkey_parse($key['key']);
    if (!empty($ssh_key['fingerprint']) && $ssh_key['fingerprint'] == devshop_public_key_valid_fingerprint()) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Check that we are getting a fingerprint at all first.
 * @return bool|string
 * @throws \SSHKeyParseException
 */
function devshop_public_key_valid_fingerprint() {

  $devshop_key = variable_get('devshop_public_key', '');
  $command = '<code>drush @hostmaster vset devshop_public_key "$(cat ~/.ssh/id_rsa.pub)" --yes</code>';

  if (empty($devshop_key)) {
    drupal_set_message(t("DevShop does not know what the server's public SSH Key is. Run the command: !command", array(
      '!command' => $command,
    )), 'error');
    return FALSE;
  }

  try {
    $devshop_sshkey = sshkey_parse($devshop_key);
  }
  catch (Exception $e) {
    drupal_set_message(t("The ssh key saved in DevShop was invalid. Run the command to re-import it: !command", array(
      '!command' => $command,
    )), 'error');
    return FALSE;
  }

  return $devshop_sshkey['fingerprint'];
}

/**
 * @param $pr
 * @param $environment
 */
function devshop_github_save_pr_env_data($pr, $environment) {
  $info = new stdClass();
  $info->id = $pr->id;
  $info->number = $pr->number;
  $info->project_nid = $environment->project_nid;
  $info->environment_name = $environment->name;
  $info->pull_request_object = serialize($pr);

  // Last minute check for existing PR info
  $results = db_select('hosting_devshop_github_pull_requests', 'pr')
    ->condition('id', $pr->id)
    ->fields('pr', array('id'))
    ->execute()
    ->fetchAssoc();

  // If there are results, save $update param for drupal_write_record().
  if (empty($results)) {
    $update = array();
  }
  else {
    $update = array('id');
  }

  // Save environment record.
  try {
    drupal_write_record('hosting_devshop_github_pull_requests', $info, $update);
    return TRUE;
  }
  catch (\PDOException $e) {
    return FALSE;
  }
}

/**
 * Function to create all PR environments for a project. Used by the Github
 * queue and on project Node Insert.
 */
function devshop_github_create_all_pr_environments($project_node) {

  // Load all PRs from GitHub API
  $project = $project_node->project;
  try {
    $prs_data = devshop_github_client()->pullRequests()->all($project->github_owner, $project->github_repo);
  } catch (\Exception $e) {
    drupal_set_message(t("Unable to load Pull Requests: !message", array('!message' => $e->getMessage())));
    return;
  }
  foreach ($prs_data as $pr) {
    $pr = convert_to_object($pr);
    $slug = "pr{$pr->number}";
    $prs[$slug] = $pr;
  }
  $prs_to_create_environments_for = $prs;
  $deployed_environments = 0;
  $deleted_environments = 0;

  // Step 1: Update existing existing environments, populate $prs_to_create_environments_for,
  // and queue "delete", "deploy", or "install" tasks for PRs depending on their state.
  // For each existing PR environment on DevShop:
  foreach ($project->environments as $environment) {
    $site_url = url("node/{$environment->site}", array('absolute' => true));
    drush_log("Checking $environment->name... [$site_url]");

    // If no PR data in environment and no PR exists with this environments name, it is not a PR environment. Move on.
    if (empty($environment->github_pull_request->pull_request_object->id) && empty($prs[$environment->name])) {
      continue;
    }
    // If no PR data, but the environment name matches a PR's slug, update data.
    // Handles the edge case where a pr123 environment lost it's github PR info.
    elseif (empty($environment->github_pull_request->pull_request_object->id) && !empty($prs[$environment->name])) {
      devshop_github_save_pr_env_data($prs[$environment->name], $environment);
      drush_log(
        "Environment found with the name '$environment->name'. Assuming it is a PR environment. Updating it with PR data and removing it from the list of environments to create. [$site_url]",
        "warning"
      );
      unset($prs_to_create_environments_for[$environment->name]);
    }
    // If there IS PR data in the environment and the PR exists on GitHub, update the PR data.
    elseif (!empty($environment->github_pull_request->pull_request_object->id) && !empty($prs[$environment->name])) {
      devshop_github_save_pr_env_data($prs[$environment->name], $environment);
      drush_log("PR environment found and updated: $environment->name [$site_url]", "ok");
      unset($prs_to_create_environments_for[$environment->name]);
    }

    // If there IS PR data on this environment and the PR does NOT exist, update the PR info, and queue it for deletion.
    elseif (!empty($environment->github_pull_request->pull_request_object->id) && empty($prs[$environment->name])) {
      devshop_github_save_pr_env_data($prs[$environment->name], $environment);
      drush_log("PR environment $environment->name exists but PR has been closed. [$site_url]", "ok");
      if ($project->settings->github['pull_request_environments_delete'] && empty($environment->tasks['delete'])) {
        drush_log("PR environment scheduled for deletion: $environment->name [$site_url]", "ok");
        hosting_add_task($environment->site, 'delete', array('force' => 1));
        $deleted_environments++;
      }

      // Since this PR is closed, and the site is scheduled for deletion, don't
      // run any further tasks on the site.
      continue;
    }

    // Deploy Task Detection.
    // Read current SHA from the environment repo_path
    $environment->git_sha = file_exists($environment->repo_path)? trim(shell_exec("cd {$environment->repo_path}; git rev-parse HEAD  2> /dev/null")): NULL;

    // If Site was installed properly and is still enabled, and repo_path is a real folder, and environment git_sha is not empty, and local git_sha does not match github PR sha...
    if ($environment->site_status == HOSTING_SITE_ENABLED && file_exists($environment->repo_path) && !empty($environment->git_sha) &&  $environment->git_sha != $prs[$environment->name]->head->sha) {
      drush_log(dt("Environment @name SHA (@e) and PR SHA (@p) are different. Preparing a deploy task... [@url] ", array(
        '@name' => $environment->name,
        '@e' => $environment->git_sha,
        '@p' => $prs[$environment->name]->head->sha,
        '@url' => $site_url,
      )), "ok");


      // Check for queued deploy tasks. If there are none, create one.
      $queued_deploy_tasks = hosting_get_new_tasks(1, $environment->site, 'devshop-deploy');
      if (count($queued_deploy_tasks) == 0) {

        // Trigger deploy task to get latest code.
        // Pass no args to skip DB updates, cache clearing, etc.
        drush_log("PR environment scheduled for deployment: $environment->name $environment->git_ref [$site_url]", "ok");
        hosting_add_task($environment->site, 'devshop-deploy', array(
          'git_ref' => $environment->git_ref,
        ));
        $deployed_environments++;
      }
      else {
        drush_log("PR environment deployment skipped: $environment->name $environment->git_ref [$site_url]", "ok");
      }

      // If site is set to rebuild, trigger "install" with force-reinstall
      if ($project->settings->github['pull_request_reinstall']) {
        drush_log("PR environment scheduled for reinstallation: $environment->name [$site_url]", "ok");
        $queued_deploy_tasks = hosting_get_new_tasks(1, $environment->site, 'install');
        if (count($queued_deploy_tasks) == 0) {
          hosting_add_task($environment->site, 'install', array('force-reinstall' => 1));
        }
        else {
          drush_log("PR install task skipped: there is already a task in the queue.", "ok");
        }
      }
    }
    drush_log("PR Processing complete for $environment->name", "ok");
    drush_log("", "ok");
    drush_log("", "ok");
    drush_log("", "ok");

  }


  // Step 2: For all PRS that do not have an environment, create one.
  foreach ($prs_to_create_environments_for as $slug => $pr) {
    drush_log("Creating environment for PR $pr->number ...", "ok");
    $branch = $pr->head->ref;

    // If PR has different remote URL, set it.
    if ($pr->head->repo->fork) {
      // Try to match project URL scheme
      if (strpos($project->git_url, 'https://') === 0) {
        $remote_url = $pr->head->repo->clone_url;
      }
      elseif (strpos($project->git_url->git_url, 'git://') === 0){
        $remote_url = $pr->head->repo->git_url;
      }
      elseif (strpos($project->git_url->git_url, 'git@') === 0){
        $remote_url = $pr->head->repo->ssh_url;
      }
      else {
        $remote_url = $pr->head->repo->clone_url;
      }
    }

    // If not a fork, use the same git_ref as project.
    else {
      $remote_url = $project->git_ref;
    }

    // @TODO: Create a "PR Env pattern" setting.
    $environment_name = $slug;

    // If method is "install"...
    if ($project->settings->github['pull_request_environments_method'] == 'devshop__github__install') {

      // Create environment then save PR data.
      // @TODO: Unify this into one function.
      $environment = hosting_create_environment($project, $environment_name, $branch, NULL, NULL, 'create', $remote_url);
      devshop_github_save_pr_env_data($pr, $environment);

      drush_log("Environment $environment_name created for $project_node->title via installation profile.", "ok");
    }
    // If environment exists for "pull_request_environments_method" setting, clone it.
    elseif (isset($project->environments[$project->settings->github['pull_request_environments_method']])) {
      $source_env = $project->settings->github['pull_request_environments_method'];

      // Create environment then save PR data.
      // @TODO: Unify this into one function.
      $environment = hosting_create_environment($project, $environment_name, $branch, $source_env, NULL, 'create', $remote_url);
      devshop_github_save_pr_env_data($pr, $environment);
      drush_log("Environment $environment_name created for $project_node->title via cloning $source_env...", "ok");
    }
    // If environment does not exist, note that error.
    elseif (!isset($project->environments[$project->settings->github['pull_request_environments_method']])) {
      drush_log("No environment found named {$project->settings->github['pull_request_environments_method']}", "warning");
    }
    // If "pull_request_environments_method" is something else, we don't know what to do.
    else {
      drush_log("Unknown PR environment creation method: {$project->settings->github['pull_request_environments_method']}", "warning");
    }
  }

  // Process $prs_to_create_environments_for
  drush_log( format_plural(count($prs_to_create_environments_for),  "1 environment created.", t("!count Environments created.", array(
    "!count" => count($prs_to_create_environments_for),
  ))), "ok");

  drush_log( format_plural($deployed_environments,  "1 Environment Updated.", t("!count Environments Updated.", array(
    "!count" => $deployed_environments,
  ))), "ok");

  drush_log( format_plural($deleted_environments,  "1 Environment Deleted.", t("!count Environments Deleted.", array(
    "!count" => $deleted_environments,
  ))), "ok");

}
