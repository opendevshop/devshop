<?php

/**
 * @file devshop_github.module
 */

require_once('includes/queue.inc');
require_once('includes/admin.inc');

/**
 * Retrieve the token from either environment variable or drupal variable.
 * @return mixed
 */
function devshop_github_token() {

  // If ENV var is set, use that instead
  if (!empty($_SERVER['GITHUB_TOKEN'])) {
    $github_token = $_SERVER['GITHUB_TOKEN'];
  }

  // If no ENV var, load Drupal variable.
  else {
    $github_token = variable_get('devshop_github_token', '');
  }

  return $github_token;
}

/**
 * Check if a token is valid. Checks the stored token if none is passed in.
 *
 * @param null $token
 *   A specific token to check.
 *
 * @return bool|\Exception
 */
function devshop_github_token_is_valid($token = NULL) {

  if (empty($token)) {
    $token = devshop_github_token();
  }

  $client = new \Github\Client();
  $client->authenticate($token, \Github\AuthMethod::ACCESS_TOKEN);

  try {
    $show = $client->currentUser()->show();
    return TRUE;
  }
    // Happens when user has no public keys.
  catch (Exception $e) {
    return false;
  }
}

/**
 * Get a GitHub client.
 *
 * If a devshop_github_token is not found, it will attempt to use the Public API.
 *
 * @param bool $must_authenticate
 *   Set to TRUE if the client must authenticate with a token. If TRUE and token
 *   is not present, an Exception will be thrown.
 *
 * @return \Github\Client
 * @throws Exception
 */
function devshop_github_client($must_authenticate = FALSE) {
  $client = new \Github\Client();

  $github_token = devshop_github_token();

  // If caller requires authentication, throw exception if token is missing.
  if ($must_authenticate && empty($github_token)) {
    throw new \Exception(t('There is no GitHub Token set, but is required for this action.'));
  }

  // If a token is found, authenticate.
  if (!empty($github_token)) {

    // Set token in client.
    $client->authenticate($github_token, \Github\AuthMethod::ACCESS_TOKEN);
    try {
      // If currentUser()->show() worked, we know we are authenticated.
      $client->currentUser()->show();
    }
    catch (Exception $e) {
      // If error, set_message and throw the exception upstream.
      drupal_set_message(t('Error validating GitHub token: ') . $e->getMessage(), 'error');
      throw $e;
    }
  }

  return $client;
}


/**
 * Implements hook_menu().
 */
function devshop_github_menu() {
  $items = array();

  $items['admin/hosting/github/add-key'] = array(
    'title' => 'Add public key to GitHub Account',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('devshop_github_add_key_to_account'),
    'access arguments' => array('administer projects'),
    'file' => 'add-key.inc',
    'file path' => drupal_get_path('module', 'devshop_github') . '/includes',
    'type' => MENU_CALLBACK,
  );
  $items['admin/hosting/github/load-repos'] = array(
    'title' => 'Load all repos that the user has access to.',
    'page callback' => 'devshop_github_get_repositories_page',
    'access arguments' => array('administer projects'),
    'file' => 'admin.inc',
    'file path' => drupal_get_path('module', 'devshop_github') . '/includes',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter() for project_node_form().
 */
function devshop_github_form_project_node_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#node'];
  $project = $node->project;
  $prs_url = $project->git_repo_url . '/pulls';
  if ($node->project->git_provider != 'github') {
    return;
  }

  //All settings git pull in project page
  $form['project']['settings']['github'] = array(
      '#type' => 'fieldset',
      '#group' => 'project_settings',
      '#collapsible' => TRUE,
      '#collapsed' => arg(1) != $node->nid,
      '#title' => t('GitHub Integration'),
      '#weight' => -10,
  );
  $form['project']['settings']['deploy']['default_hooks']['#weight'] = -9;


  // If Pull Requests were found in the environment, enable PR environments by default.
  $prs = [];
  try {
      $prs = devshop_github_client()->pullRequests()->all($node->project->github_owner, $node->project->github_repo);
  }
  catch (\Exception $e) {
    drupal_set_message(t("Something went wrong when looking up PRs: for the GitHub repo !link: %message", array(
      '!link' => l("{$node->project->github_owner}/{$node->project->github_repo}", $node->project->git_repo_url),
      '%message' => $e->getMessage(),
    )), 'error');
  }

  $pr_count = count($prs);
  if (!isset($node->project->settings->github) && $pr_count > 0) {
    $node->project->settings->github = array(
      'pull_request_environments' => true,
      'pull_request_environments_delete' => true,
    );
  }

  $form['found_prs'] = array(
    '#type' => 'markup',
    '#prefix' => '<div class="alert alert-success">',
    '#suffix' => '</div>',
    '#weight' => -1000,
    '#markup' => implode(' ', array(
      format_plural($pr_count, t('There is 1 open Pull Request in your project.'), t('There are @number open Pull Requests in your project', array('@number' => $pr_count))),
      t('Check pull request environment settings in the "GitHub Integration" section.'),
      l(t('View Pull Requests on GitHub.com'), $node->project->git_repo_url . '/pulls', array(
        'attributes' => array(
          'target' => '_blank',
        ),
      ))
    )),
  );

  $form['project']['settings']['github']['pull_request_environments'] = array(
    '#title' => t('Create Pull Request Environments'),
    '#description' => t('Maintain an environment for every !open_pull_request.', array(
      '!open_pull_request' => l(t('open Pull Request (@count)', array(
        '@count' => $pr_count,
      )), $prs_url, array(
        'attributes' => array(
          'target' => '_blank',
        ),
      )),
    )),
    '#type' => 'checkbox',
    '#field_prefix' => '<span class="text-success">' . format_plural($pr_count,
      t('The project has one open Pull Request'),
      t('The project has @number open Pull Requests', array(
        '@number' => $pr_count,
      )) . '</span>'
    ),
    '#default_value' => isset($project->settings->github) ?
      $project->settings->github['pull_request_environments'] :
      false,
  );

  // Delete Pull Request environments?
  $form['project']['settings']['github']['pull_request_environments_delete'] = array(
      '#type' => 'checkbox',
      '#title' => t('Delete Environments for Closed Pull Requests'),
      '#default_value' => isset($node->project->settings->github) ? $node->project->settings->github['pull_request_environments_delete'] : 1,
      '#states' => array(
        'visible' => array(
          ':input[name="project[settings][github][pull_request_environments]"]' => array('checked' => TRUE),
        ),
      ),
  );
  $form['project']['settings']['github']['pull_request_auto_merge'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable GitHub Auto-Merge. <div class="help-block">When creating the github deployment, tell it to attempt to automatically merge changes in from the primary branch. </div><div class="help-block"><span class="text-warning">WARNING: This will prevent deployment notifications if the branch cannot be merged because of a conflict. DevShop will send a message to GitHub notifying the developers they must resolve the conflicts to continue deployment notifications</span></div>'),
    '#default_value' => isset($node->project->settings->github) ?
      $node->project->settings->github['pull_request_auto_merge'] : 1,
    '#states' => array(
      'visible' => array(
        ':input[name="project[settings][github][pull_request_environments]"]' => array('checked' => TRUE),
      ),
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter() for site_node_form().
 *
 * Add the list of PRs to the Branch selector.
 */
function devshop_github_form_hosting_task_confirm_form_alter(&$form, &$form_state, $form_id) {

  $form['#submit'][] = 'devshop_github_form_hosting_task_confirm_form_alter_submit';
}

/**
 *
 */
function devshop_github_form_hosting_task_confirm_form_alter_submit($form, &$form_state) {
  $values = $form_state['values'];
//  DevShopGitHubApi::createDeployment();
}

/**
 * Implements hook_form_FORM_ID_alter() for site_node_form().
 *
 * Add the list of PRs to the Branch selector.
 */
function devshop_github_form_site_node_form_alter(&$form, &$form_state, $form_id) {

  $project = $form_state['project'];

  // Don't try to load PRs if there isn't even a token.
  if (arg(1) == 'add' && $project->git_provider == 'github'){
    try {
      $prs = devshop_github_client()->pullRequests()->all($project->github_owner, $project->github_repo);
      $default_branch = devshop_github_client()->repo()->show($project->github_owner, $project->github_repo)['default_branch'];
    }
    catch (\Exception $e) {
      drupal_set_message(t('Unable to reach GitHub API to load Pull Request Data. [Error: %error]', array(
        '%error' => $e->getMessage(),
      )), 'warning');
      return;
    }


    // @TODO: Use the new function devshop_github_pr_options().
    $pr_options = array();
    $existing_options = $form['git_ref']['#options'];

    if (count($prs)) {
      foreach ($prs as $pr) {
        $pr_description = implode(' - ', array(
          "PR {$pr['number']}",
          $pr['head']['ref'],
          $pr['user']['login'],
          $pr['title'],
        ));
        $option_name = $pr['head']['ref'];
        $pr_options['Pull Requests'][$option_name] = $pr_description;
        $form_state['pull_requests'][$option_name] = $pr;
      }

      $form['git_ref']['#title'] = t('Branch, Tag, or Pull Request');
    }

    $default_branch_option = array(
      t('Default Branch') => array(
        $default_branch => $default_branch . ' (' . t('Default Branch') . ')',
      ),
    );

    unset($existing_options[t('Branches')][$default_branch]);

    $form['git_ref']['#options'] = array_merge($default_branch_option, $pr_options, $existing_options);
    $form['git_ref']['#default_value'] = $form['git_ref']['#default_value'] ?? $default_branch;

    $form['git_ref']['#element_validate'] = array(
      'devshop_github_form_site_node_form_validate_pr'
    );
  }
}

/**
 * Look up all PRs and return an array for a select form.
 *
 * @param $project
 *
 * @return array
 */
function devshop_github_pr_options($project, $key = 'id', $prs = array()) {
  $pr_options = array();

  if (empty($prs)) {
    try {
      $prs = devshop_github_client()->pullRequests()->all($project->github_owner, $project->github_repo);
    }
    catch (\Exception $e) {
      drupal_set_message(t('Unable to reach GitHub API to load Pull Request Data. [Error: %error]', array(
        '%error' => $e->getMessage(),
      )), 'error');
      drupal_set_message(l(t('Check your GitHub Settings'), 'admin/hosting'), 'error');
      return $pr_options;
    }
  }

  foreach ($prs as $pr) {
    $pr_description = implode(' - ', array(
      "PR {$pr['number']}",
      $pr['head']['ref'],
      $pr['user']['login'],
      $pr['title'],
    ));
    // If user wants "ref" for key, it's in "head" array.
    $pr['ref'] = $pr['head']['ref'];
    if (!isset($pr[$key])) {
      throw new \Exception("Item '$key' not found in \$pr array. The PR keys are: " . implode(',', array_keys($pr)));
    }
    $option_name = $pr[$key];
    $pr_options[$option_name] = $pr_description;
  }
  return $pr_options;
}

/**
 * @param $element
 * @param $form_state
 */
function devshop_github_form_site_node_form_validate_pr($element, &$form_state, $form)
{
  // If PR found for this branch, put the PR data into form_state.

  // @TODO: Load PR based on number.
  if (!empty($form_state['pull_requests'][$element['#value']])) {
    $form_state['values']['pull_request'] = $pr = convert_to_object($form_state['pull_requests'][$element['#value']]);

    // If PR has different remote URL, set it.
    if ($pr->head->repo->fork) {
      // Try to match project URL scheme
      if (strpos($form_state['project']->git_url, 'https://') === 0) {
        $remote_url = $pr->head->repo->clone_url;
      }
      elseif (strpos($form_state['project']->git_url, 'git://') === 0){
        $remote_url = $pr->head->repo->git_url;
      }
      elseif (strpos($form_state['project']->git_url, 'git@') === 0){
        $remote_url = $pr->head->repo->ssh_url;
      }
      else {
        $remote_url = $pr->head->repo->clone_url;
      }

      // Recreate the platform node, with the new git git_remote.
      $platform_node = devshop_prepare_platform_node($form_state['project'], $form_state['environment_name'], $form_state['values']['git_ref'], $form_state['values']['web_server'], $form_state['values']['git']['git_remote']);
      $platform_node->no_verify = TRUE;
      form_set_value($form['platform_node'], $platform_node, $form_state);
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function devshop_github_form_devshop_project_create_step_git_alter(&$form, &$form_state, $form_id) {

  module_load_include('inc', 'devshop_github', 'includes/admin');
  $key_exists = devshop_github_token();
  $key_valid = devshop_github_token_is_valid();

  if ($key_exists && !$key_valid && drupal_valid_path('admin/hosting')) {
    drupal_set_message(t('Your GitHub API Token is invalid. Check !settings to add a new one.', [
      '!settings' => l(t('DevShop GitHub Settings'), 'admin/hosting'),
    ]), 'error');
  }
  elseif (!$key_exists && drupal_valid_path('admin/hosting')) {
    drupal_set_message(t('GitHub API Integration has not been enabled. You can still add public git repositories. Check !settings to enable additional features.', [
      '!settings' => l(t('DevShop GitHub Settings'), 'admin/hosting'),
    ]), 'warning');
  }

  $options = [];
  $repos = variable_get('devshop_github_available_repositories', array());
  if (empty($repos)) {
    $repos = variable_get('devshop_github_all_repositories', array());
  }
  foreach ($repos as $repo_name => $repo) {
    $form['source']['choice']['#options']["GitHub: " . $repo['org']][$repo['url']] = $repo_name;
  }

  $form['source']['github_create'] = array(
    '#type' => 'container',
    '#tree' => TRUE,
    '#attributes' => array(
      'class' => array(
        'form-group'
      ),
    ),
    '#states' => array(
      'visible' => array(
        ':input[name="git_source"]' => array(
          'value' => 'github_create'
        ),
      ),
    ),
    '#parents' => array(
      'github_create',
    ),

  );

  try {
    $client = devshop_github_client();
    $account = $client->currentUser()->show();
    $repo_owners = variable_get('devshop_github_available_organizations', array('' => t('You do not have repository create permissions for any organizations.')));
    $repo_owners[$account['login']] = $account['login'];

    asort($repo_owners);
    $form['source']['github_create']['github_organization'] = array(
      '#type' => 'select',
      '#title' => t('Create a new GitHub repository'),
      '#options' => $repo_owners,
      '#bootstrap_ignore_pre_render' => TRUE,
      '#attributes' => array(
        'class' => array(
          'form-control form-inline'
        ),
      ),
    );
    $form['source']['github_create']['github_repository_name'] = array(
      '#type' => 'textfield',
      '#attributes' => array(
        'placeholder' => t('repo_name'),
        'class' => array('form-inline'),
      ),
      '#element_validate' => array(
        'devshop_github_create_repository'
      ),
    );
    $form['source']['github_create']['github_repository_public'] = array(
      '#type' => 'radios',
      '#options' => array(
        1 => t('Public: Anyone can see this repository. You choose who can commit.'),
        0 => t('Private: You choose who can see and commit to this repository.')
      ),
      '#default_value' => 1,
    );
  }
  catch (\Exception $e) {
    // We've already got a message.
    //    drupal_set_message($e->getMessage(), 'warning');
  }

  $form['source']['settings']['#weight'] = 1;
  $form['source']['settings']['#tree'] = 1;
  $form['github_repository_source'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array(
        'well'
      ),
    ),
    '#states' => array(
      'visible' => array(
        ':input[name="git_source"]' => array(
          'value' => 'github_create'
        ),
      ),
    ),
    '#tree' => 1,
    '#parents' => array(
      'settings',
      'github_repository_source',
    ),
    '#access' => variable_get('devshop_allow_create_repo_github', false),
  );


//  $form['github_repository_source']['populate_choice'] = array(
////    '#prefix' => '<div class="well">',
//    '#type' => 'radios',
//    '#default_value' => 'create',
//    '#title' => t('Choose what to put into your new Git repository'),
//    '#options' => array(
//      'create' => t('Create project using composer'),
//      'import' => t('Import from another Git URL'),
//    ),
//    //'#access' => !empty($form[''['custom']),
//  );
//  dsm($form);
//
//  $suggested_repos = variable_get('devshop_project_create_choice_options', array(
//    'git@github.com:opendevshop/devshop-composer-template.git',
//  ));
//  $options = array_combine(array_values($suggested_repos),array_values($suggested_repos));
//  $options['custom'] = t('Enter a custom Git URL');

  $form['github_repository_source']['import'] = array(
    '#type' => 'textfield',
    '#attributes' => array(
      'placeholder' => t('git@githost.com:example/repo.git'),
    ),
    '#description' => t('Your new repo will be a clone of this repository on the default branch.') .' ' . l(t('Suggested Repos'), '', array(
      'attributes' => array(
        'class' => array('put-back-suggested-repos'),
      ),
    )),
    '#states' => array(
      'visible' => array(
        ':input[name="settings[github_repository_source][populate_choice]"]' => array(
          'value' => 'import'
        ),
        'select[name="settings[github_repository_source][import_suggestions]"]' => array(
          'value' => 'custom'
        ),
      ),
    ),
    '#element_validate' => array(
      'devshop_github_set_import_url'
    ),
  );

  $form['github_repository_source']['import_suggestions'] = array(
    '#type' => 'select',
    '#options' => $options,
    '#description' => t('Your new repo will be a direct clone of this repository. All commits will be loaded into the new repository.'),
    '#states' => array(
      'visible' => array(
        ':input[name="settings[github_repository_source][populate_choice]"]' => array(
          'value' => 'import'
        ),
        'select[name="settings[github_repository_source][import_suggestions]"]' => array(
          '!value' => 'custom'
        ),
      ),
    ),
  );

  $suggested_projects = variable_get('devshop_composer_project_suggestions', "devshop/composer-template:8.x-dev\ndevshop/composer-template:7.x-dev");

//  $options = array_combine(array_values($suggested_projects),array_values($suggested_projects));
  $options = [];
  $options['custom'] = t('Enter custom project');

  $form['github_repository_source']['composer_project_suggestions'] = array(
    '#type' => 'select',
    '#options' => $options,
    '#description' => t('The command above will be run and all the resulting files will be committed to your repository.'),
    '#field_prefix' => '<div class="input-group"><code class="input-group-addon">composer create-project </code>',
    '#field_suffix' => '<code class="input-group-addon input-group-addon-url">' . t('projectname') .'</code>
        </div>',
    '#states' => array(
      'visible' => array(
        ':input[name="settings[github_repository_source][populate_choice]"]' => array(
          'value' => 'create'
        ),
        'select[name="settings[github_repository_source][composer_project_suggestions]"]' => array(
          '!value' => 'custom'
        ),
      ),
    ),
  );

  $form['github_repository_source']['composer_project'] = array(
    '#type' => 'textfield',
    '#description' => t('The command above will be run and all the resulting files will be committed to your repository.') . ' ' . l(t('Suggested Projects'), '', array(
      'attributes' => array(
        'class' => array('put-back-suggested-projects'),
      ),
    )),
    '#field_prefix' => '<div class="input-group"><code class="input-group-addon">composer create-project </code>',
    '#field_suffix' => '<code class="input-group-addon input-group-addon-url"> ' . t('projectname') .'</code>
        </div>',
//    '#default_value' => $suggested_projects[0],
    '#attributes' => array(
      'placeholder' => $suggested_projects[0],
    ),
    '#states' => array(
      'visible' => array(
        ':input[name="settings[github_repository_source][populate_choice]"]' => array(
          'value' => 'create'
        ),
        'select[name="settings[github_repository_source][composer_project_suggestions]"]' => array(
          'value' => 'custom'
        ),
      ),
    ),
    '#element_validate' => array(
      'devshop_github_set_composer_project'
    ),
  );

  $form['github_repository_source']['wrapper'] = array(
    '#markup' => drupal_valid_path('admin/hosting')? l(t("Modify suggested projects in DevShop Settings"), 'admin/hosting'): '',
//    '#suffix' => '</div>',
  );

  $form['source']['git_url']['#required'] = FALSE;
  $form['source']['git_url']['#element_validate'] = array(
    'devshop_github_create_project_form_set_values'
  );

  // We have to tell the front-end what type of field so we can assign the right event.
  drupal_add_js(array(
    'devshop' => array(
      'projectNameSourceElements' => array(
        '#edit-choice',
        '#edit-github-create-github-repository-name',
      ),
    ),
  ), 'setting');

}

/**
 * Implements hook_devshop_project_git_repo_options().
 */
function devshop_github_devshop_project_git_repo_options() {

  if (devshop_github_token_is_valid()) {
    return array(
      'github_create' => t('Create a new GitHub repository'),
    );
  }
}

/**
 * @param $element
 * @param $form_state
 * @param $form
 */
function devshop_github_create_project_form_set_values($element, &$form_state, &$form) {

  $form_state['values']['settings']['git_source'] = $form_state['values']['git_source'];

  if ($form_state['values']['git_source'] == 'github_existing') {
    form_set_value($element, $form_state['values']['github_repos'] , $form_state);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alters devshop_project_create_step_environments form.
 */
function devshop_github_form_devshop_project_create_step_environments_alter(&$form, &$form_state, $form_id) {

  $project = &$form_state['project'];

  // Return if provider is not github.
  if ($project->git_provider != 'github') {
    return;
  }

  $prs_url = $project->git_repo_url . '/pulls';

  // Load the PRs.
   $settings_link = '';
  try {
    $prs = devshop_github_client()->pullRequests()->all($project->github_owner, $project->github_repo);
    $environment_forms = array();
    if (!empty($project->settings->github['pull_request_environments'])) {

      foreach ($prs as $pr) {
        // Prepare environment objects
        $env_name = "pr{$pr['number']}";
        // If PR environment already exists, load it.
        if (isset($project->environments[$env_name])) {
          $environment = convert_to_object($project->environments[$env_name]);
        }
        else {
          $environment = new stdClass();
          $environment->name = "pr{$pr['number']}";
          $environment->git_ref = $pr['head']['ref'];
          $project->environments[$environment->name] = $environment;
        }

        // Use NEW form elements as the template.
        $environment_forms[$environment->name] = $form['project']['environments']['NEW'];
//        $environment_forms[$environment->name]['platform']['#value'] = $environment->platform;

        // Create a disabled textfield for display to user, and convert original element to "value" type so the info is passed.
        $environment_forms[$environment->name]['name']['#default_value'] = $environment->name;
        $environment_forms[$environment->name]['name']['#attributes']['disabled'] = true;

        $environment_forms[$environment->name]['git_ref']['#value'] = $environment->git_ref;
        $environment_forms[$environment->name]['git_ref']['#type'] = 'value';
        $icon = $project->settings->git['refs'][$environment->git_ref] == 'branch' ? 'code-fork': 'tag';

        $environment_forms[$environment->name]['git_ref']['info']['ref'] = array(
          '#theme' => 'link',
          '#text' => "<em class='fa fa-$icon'></em> " . $environment->git_ref,
          '#path' => $pr['html_url'],
          '#options' => array(
            'html' => true,
            'attributes' => array(
              'target' => '_blank',
              'class' => array(
                'btn btn-default btn-sm'
              ),
            ),
          ),
        );
        $environment_forms[$environment->name]['git_ref']['info']['pr'] = array(
          '#theme' => 'link',
          '#text' => "<img src='{$pr['user']['avatar_url']}' width='28' class='img-responsive img-thumbnail'> PR" . $pr['number'] . htmlentities($pr['title']),
          '#path' => $pr['html_url'],
          '#options' => array(
            'html' => true,
            'attributes' => array(
              'target' => '_blank',
              'class' => array(
                'btn btn-text'
              ),
            ),
          ),
        );

        // If PR has different remote URL, set it.
        if ($pr['head']['repo']['fork']) {
          // Try to match project URL scheme
          if (strpos($project->git_url, 'git://') === 0){
            $remote_url = $pr['head']['repo']['git_url'];
          }
          elseif (strpos($project->git_url, 'git@') === 0){
            $remote_url = $pr['head']['repo']['ssh_url'];
          }
          else {
            $remote_url = $pr['head']['repo']['clone_url'];
          }
        }
        else {
          $remote_url = $project->git_url;
        }

        $environment_forms[$environment->name]['settings']['git_remote'] = array(
          '#type' => 'value',
          '#value' => $remote_url,
        );

        // Save data for devshop_github_node_insert() to process.
        $environment_forms[$environment->name]['settings']['pull_request'] = array(
          '#type' => 'value',
          '#value' => $pr,
        );

        $form['project']['primary_environment']['#options'][$env_name] = $env_name;
      }

      // Merge environments fields together to put PRs on top.
      $form['project']['environments'] = array_merge($form['project']['environments'], $environment_forms);
    }

    $settings_link = l(t('Change Project Settings'), 'projects/add/settings', array(
      'fragment' => 'edit-project-settings-github',
    ));

    $prs_link = l(t('Pull Requests for @repo: @count', array(
      '@repo' => $project->github_owner . '/' . $project->github_repo,
      '@count' => count($prs),
    )), $prs_url, array(
      'attributes' => array('target' => '_blank')
    ));

    // Project with PR environments disabled.
    if (empty($project->settings->github['pull_request_environments'])) {
      $help_display['help'] = array(
        '#theme' => 'item_list',
        '#items' => array(
          t('Pull Request environments are disabled for this project.'),
          $prs_link,
          $settings_link,
        ),
        '#prefix' => '<div class="alert alert-warning">',
        '#suffix' => '</div>',
      );
    }
    // Project configured to maintain all PR environments.
    elseif (!empty($project->settings->github['pull_request_environments'])) {
      $help_display['help'] = array(
        '#theme' => 'item_list',
        '#items' => array(
          t('Project is configured to create environments for every open Pull Request.'),
          $prs_link,
          $settings_link,
        ),
        '#prefix' => '<div class="alert alert-info">',
        '#suffix' => '</div>',
      );
    }
  }
  catch (\Exception $e) {
    $help_display['gh_error'] = array(
      '#theme' => 'item_list',
      '#items' => array(
        t('GitHub authentication failed. Check your token at !link. The error was: %message', array(
          '%message' => $e->getMessage(),
          '!link' => l('DevShop GitHub Settings', 'admin/hosting'),
        )),
        $settings_link,
      ),
      '#prefix' => '<div class="alert alert-danger">',
      '#suffix' => '</div>',
    );
  }
  $form['pr_environments']['help'] = $help_display;
  $form['pr_environments']['help']['#weight'] = -1;

  $repo = $project->git_repo_url;
  $repo_url = $project->git_repo_url;
  $l_options = [
    'attributes' => [
      'target' => '_blank',
    ]
  ];
  //@TODO: Detect permission for adding webhook.
  $form['github_webhook'] = array(
    '#title' => t('Setup GitHub Webhook'),
    '#type' => 'checkbox',
    '#description' => t('Leave this box checked to automatically add a webhook to your GitHub Repository !link. Your server must be reachable by the !servers', array(
      '!link' => l($repo, $repo_url, $l_options),
      '!servers' => l(t('GitHub Servers listed under "hooks" in the API'), 'https://api.github.com/meta', $l_options),
      '#type' => 'checkbox',
      '#default_value' => variable_get('devshop_github_webhook_setup_default', 0),
    )));

  $form['#validate'][] = 'devshop_github_project_create_webhook';
  $form['#submit'][] = 'devshop_github_project_create_webhook';

}

/**
 * @param $element
 * @param $form_state
 * @param $form
 */
function devshop_github_set_import_url($element, &$form_state, &$form) {
  if ($form_state['values']['settings']['github_repository_source']['import_suggestions'] != 'custom') {
    form_set_value($element, $form_state['values']['settings']['github_repository_source']['import_suggestions'], $form_state);
  }
}

/**
 * @param $element
 * @param $form_state
 * @param $form
 */
function devshop_github_set_composer_project($element, &$form_state, &$form) {
  if ($form_state['values']['settings']['github_repository_source']['composer_project_suggestions'] != 'custom') {
    form_set_value($element, $form_state['values']['settings']['github_repository_source']['composer_project_suggestions'], $form_state);
  }
}

/**
 * Element validation for License Key. Pings devshop.support
 *
 * @param $element
 * @param $form_state
 * @param $form
 */
function devshop_github_create_repository($element, &$form_state, &$form) {

  if ($form_state['values']['git_source'] == 'github_create') {

    if (empty($element['#value'])) {
      form_error($element, t('You must enter a repository name.'));
    }
    else {
      $client = devshop_github_client();
      $name = $element['#value'];
      // Must be NULL if org is username.
      $organization = $form_state['values']['github_create']['github_organization'] == $client->currentUser()->show()['login']? NULL: $form_state['values']['github_create']['github_organization'];
      $public = $form_state['values']['github_create']['github_repository_public'];
      $description = t('Created by DevShop on @date', array('@date' => format_date(time())));

      try {
        $repo = $client->repos()->create($name,
          $description,
          '',
          $public,
          $organization
        );
        form_set_value($form['source']['git_url'], $repo['ssh_url'],$form_state);
        drupal_set_message(t('New GitHub Repository was created! See !link.', array(
          '!link' => l($repo['html_url'], $repo['html_url']),
        )));
      }
      catch (\Exception $e) {
        form_error($element, t('Unable to create repo. Error from GitHub: ') . $e->getMessage());
      }
    }
  }
}

/**
 * Extra submit hook for last step of project create form.
 */
function devshop_github_project_create_webhook($form, $form_state) {

  // Return if box is not checked.
  if (empty($form_state['values']['github_webhook'])) {
    return;
  }

  // Get Project
  $project_node = node_load($form['nid']['#value']);
  $project = $project_node->project;

  // Get GitHub client
  $client = new Github\Client();
  $github_token = variable_get('devshop_github_token', '');
  $client->authenticate($github_token, \Github\AuthMethod::ACCESS_TOKEN);

  // Create the webhook.
  try {
    $hook = $client->repo()->hooks()->create($project->github_owner, $project->github_repo, array(
        'name' => 'web',
        'active' => true,
        'events' => array(
            'push',
            'pull_request',
            'delete',
            'release',
        ),
        'config' => array(
            'url' => $project->webhook_url,
            'content_type' => 'json',
            'insecure_ssl' => '1',
        ),
    ));
  }
  catch (Github\Exception\ValidationFailedException $e) {
    if ($e->getMessage() == 'Validation Failed: Hook already exists on this repository') {
      // For some reason, github always throws this exception on hooks()->create, but the webook still gets created!!

      //      drupal_set_message(t("GitHub webhook added, but there is already an existing webhook. Please check your repository's !link.", array(
//          '!link' => l(t('Webhook Settings'), $project->git_repo_url . '/settings/hooks'),
//      )), 'warning');
    }
    else {
      drupal_set_message(t('GitHub Validation Exception: !exception', array('!exception' => $e->getMessage())), 'error');
    }
  }
  catch (Github\Exception\RuntimeException $e) {
    drupal_set_message(t('GitHub Runtime Exception: !exception', array('!exception' => $e->getMessage())), 'error');
  }
}

/**
 * Implements hook_node_load().
 */
function devshop_github_node_load($nodes, $types) {

  // Load each tasks deployment object.
  $types_we_want_to_process = array('task');
  if (count(array_intersect($types_we_want_to_process, $types))) {
    $result = db_query('SELECT * FROM {hosting_devshop_github_deployments} WHERE task_nid IN(:nids)', array(':nids' => array_keys($nodes)));
    foreach ($result as $record) {
      $nodes[$record->task_nid]->github_deployment = unserialize($record->deployment_object);
    }
  }

  foreach ($nodes as $nid => &$node) {
    if ($node->type == 'project' && $node->project->git_provider == 'github') {
      // Look for a pull request object.
      $pull_requests = db_query('SELECT prs.*, e.name AS environment_name
        FROM {hosting_devshop_github_pull_requests} prs
        LEFT JOIN {hosting_devshop_project_environment} e ON prs.site_nid = e.site
        WHERE project_nid = :project_nid', array(':project_nid' => $nid));
      foreach ($pull_requests as $pull_request) {
        if (!empty($pull_request->pull_request_object)) {
          $pull_request->pull_request_object = unserialize($pull_request->pull_request_object);
          if (isset($node->project->environments[$pull_request->environment_name])) {
            $node->project->environments[$pull_request->environment_name]->github_pull_request = $pull_request;
            $node->project->environments[$pull_request->environment_name]->image = $pull_request->pull_request_object->user->avatar_url;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_node_insert().
 *
 * When submitting from the Site form, and user selects a PR branch, "pull_request" is populated with the PR object.
 */
function devshop_github_node_insert($node) {

  if ($node->type == 'site' && !empty($node->settings->pull_request) && isset($node->settings->pull_request['node_id'])) {

    $environment = new stdClass();
    $environment->name = $node->environment_name;
    $environment->site = $node->nid;

    if (!empty($node->pull_request)) {
      $pr_data = convert_to_object($node->pull_request);
    }
    elseif (!empty($node->settings->pull_request)) {
      $pr_data = convert_to_object($node->settings->pull_request);
    }
    else {
      return;
    }

    if (!devshop_github_save_pr_env_data($pr_data, $environment)) {
      throw new \Exception('Unable to save bitbucket PR data: ' . print_r($pr_data, 1));

    }
  }

  if ($node->type == 'task' && $node->task_type == 'devshop-deploy') {

    // Get the latest environment info.
    $site = node_load($node->rid, null, true);
    if ($site->type == 'site' && isset($site->environment)) {
      // Create a deployment on GitHub.
      $deployment = DevShopGitHubApi::deploy($site->environment, 'pending', $node, t('DevShop Deploy task queued.'), NULL, url("node/$node->nid", array(
        'absolute' => true,
      )));
      watchdog('devshop_github', t('DevShop Deploy Task created [%nid] and GitHub Deployment Created: [%id]'), array(
        '%id' => $deployment->id,
      ));
    }
  }
}

/**
 * Implements hook_node_update() for task insert.
 *
 * If task is a test run, send a "pending" commit status.
 */
function devshop_github_node_update($node) {

  // Only act on test triggers.
  if ($node->type != 'task' || $node->type == 'task' && ($node->task_type != 'test' || $node->task_type != 'deploy')) {
    return;
  }

  // Load the site and check for environment.
  $site = node_load($node->rid);
  if (empty($site->environment) || empty($site->environment->github_pull_request) || empty($site->environment->settings->deploy['test'])) {
    return;
  }

  try {
    $token = variable_get('devshop_github_token', '');
    $client = new \Github\Client();
    $client->authenticate($token, \Github\AuthMethod::ACCESS_TOKEN);

    // Create a deployment status
    $project = $site->project;
    $owner = $site->environment->github_owner;
    $repo = $site->environment->github_repo;

    $sha = devshop_environment_get_git_sha($site->environment->repo_path);

    $params = new stdClass();
    $params->state = 'pending';

    if ($node->task_type != 'test') {
      $params->target_url = url(
        "node/{$node->nid}",
        array('absolute' => true)
      );
      $params->description = t('DevShop: Run Tests');
      $params->context = "devshop/{$project->name}/tests";
    }
    elseif ($node->task_type != 'deploy') {
      $params->target_url = $site->environment->url;
      $params->description = t('DevShop: Deploy');
      $params->context = "devshop/{$project->name}/deploy";
    }

    // Post status to github
    $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));

    watchdog('devshop_github','Test run initiated. GitHub has been notified.');
  } catch (Github\Exception\RuntimeException $e) {
    watchdog('devshop_github', 'GitHub Runtime Error in devshop_github_node_update(): ' . $e->getMessage());
  }
}


/**
* Implements hook_hosting_task_update_status()
*/
// function devshop_github_hosting_task_update_status($task, $status) {
//
//  $task_types = array(
//    'test',
//    'import',
//    'devshop-deploy',
//  );
//
//  if (in_array($task->task_type, $task_types) && $task->ref->type == 'site' && isset($task->ref->environment->github_pull_request)) {
//
//    // If autoloader is not available, return.
//    if (!file_exists(__DIR__ . '/vendor/autoload.php')) {
//      return;
//    }
//
//    // If project is not from github, return.
//    if ($task->ref->project->git_provider != 'github') {
//      return;
//    }
//
//    // Include vendors
//    require_once 'vendor/autoload.php';
//
//    drush_log('===========================================', 'ok');
//    drush_log('Notifying github...', 'ok');
//
//    // Extract username and repo
//    list($s, $owner, $repo) = explode('/', parse_url($task->ref->project->git_repo_url, PHP_URL_PATH));
//
//    try {
//      $token = variable_get('devshop_github_token', '');
//      $client = new \Github\Client();
//      $client->authenticate($token, \Github\AuthMethod::ACCESS_TOKEN);
//
//      // Create a status
//      $sha = $task->ref->environment->github_pull_request->pull_request_object->head->sha;
//
//      if ($task->task_type == 'devshop-deploy'){
//        $description = t('Deployed to Environment: ') . _hosting_parse_error_code($status);
//        $url = $task->ref->environment->url;
//      }
//      elseif ($task->task_type == 'test') {
//        $description = t('Tests: ') . _hosting_parse_error_code($status);
//        $url = url("devshop_tests/{$task->nid}/{$task->vid}", array('absolute' => TRUE));
//      }
//      else {
//        $description = 'Something happened...';
//        $url = $task->ref->environment->url;
//      }
//
//      if ($status == HOSTING_TASK_ERROR) {
//        $state = 'error';
//      }
//      elseif ($status == HOSTING_TASK_PROCESSING) {
//        $state = 'pending';
//      }
//      elseif ($status == HOSTING_TASK_SUCCESS || $status == HOSTING_TASK_WARNING) {
//        $state = 'success';
//      $params->context = 'devshop/' . $task->task_type;
//
//      $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
//
//      drush_log('Status posted! ', 'ok');
//    } catch (Github\Exception\RuntimeException $e) {
//      drush_log('GitHub API Error: ' . $e->getMessage(), 'error');
//      drush_log(l(t('Configure GitHub API'), 'admin/hosting/github'), 'error');
//    } catch (Github\Exception\ValidationFailedException $e) {
//      drush_log('GitHub API Error: ' . $e->getMessage(), 'error');
//    }
//
//    drush_log('done trying... ', 'ok');
//
//  }
// }

//      }
//      else {
//        $state = 'error';
//      }
//
//      $params = new stdClass();
//      $params->state = $state;
//      $params->target_url = $url;
//      $params->description = $descriptio
/**
 *
 */
function devshop_github_comment($task, $status) {

  $output = array();
  $output[] = '> **DEVSHOP**';
  $output[] = '> ' . ucfirst($task->task_type) .  ": " . _hosting_parse_error_code($status);
  $output[] = '> Site: ' . $task->ref->environment->url;
  $output[] = '> Project: ' . url("node/{$task->ref->project->nid}", array('absolute' => TRUE));

  if ($task->task_type == 'test') {
    $output[] = 'Results: ' . url("node/{$task->nid}", array('absolute' => TRUE));
  }

  if ($task->task_type == 'import') {
    $output[] = t('Your environment is now available.');
  }

  return implode("\n", $output);
}



/**
 * GitHub action to take on webhook init
 */
function devshop_github_webhook($project_node) {
  $headers = getallheaders();
  $project = $project_node->project;

  // @TODO: Handle form content from github as well.
  if ($headers['Content-Type'] == 'application/json' || $headers['content-type'] == 'application/json') {
    $data = json_decode(file_get_contents('php://input'));

    $args = array();
    $args['cache'] = 1;

    if (isset($headers['X-Github-Event'])) {
      $github_event = $headers['X-Github-Event'];
    }
    elseif (isset($headers['X-GitHub-Event'])) {
      $github_event = $headers['X-GitHub-Event'];
    }
    else {
      $github_event = '';
    }

    switch ($github_event) {
      case 'ping':
        $message = 'Pong!';
        break;
      case 'push':

        // If push is for a deleted branch, don't do anything.
        if ($data->deleted && $data->after == "0000000000000000000000000000000000000000") {
          $message = 'Deleted ref detected.';
          break;
        }

        // Limit "Deploy" tasks to only run for the branches we have new code for..
        $git_ref = strtr($data->ref, array('refs/tags/' => '', 'refs/heads/' => ''));

        // Check for environments set to pull
        $environments_to_pull = array();
        $message = "Push Received for git ref $git_ref.";

        foreach ($project->environments as $environment_name => $environment) {

          // Only pull if deploy is not disabled or if environment is tracking a tag.
          if (
//            @TODO: Improve this. If a site install failed, it shows up as "disabled", so we should still do a git pull.
            $git_ref == $environment->git_ref &&
            $environment->hosting_settings['deployment']['continuous'] &&
            !in_array($environment->git_ref, $project->settings->git['tags'])
          ) {
            $environments_to_pull[] = $environment->name;

            if (isset($environment->site) && $node = node_load($environment->site)) {

              // If project is set to reinstall pull request environments, and this is a pull request environment, run a forced install task.
              if (isset($project->settings->github['pull_request_reinstall']) && $project->settings->github['pull_request_reinstall'] && isset($environment->github_pull_request)) {

                // Trigger deploy task to get latest code.
                // Pass no args to skip DB updates, cache clearing, etc.
                hosting_add_task($environment->site, 'deploy', array(
                  'git_ref' => $environment->git_ref,
                ));

                // Trigger "install" with force-reinstall
                hosting_add_task($environment->site, 'install', array('force-reinstall' => 1));
              }

              // Otherwise, just run a "deploy" task.
              else {

                // Default args to the environments deploy settings.
                $args = $environment->settings->deploy;
                $args['git_ref'] = $environment->git_ref;
                hosting_add_task($environment->site, 'deploy', $args);
              }
            }
          }
        }

        if (empty($environments_to_pull)) {
          $message .= "No environments tracking this branch. ";
        }
        else {
          $message .= "Deploying code to environments: " . implode(', ', $environments_to_pull);
        }
        break;

      case 'pull_request':
        // If pull request environments is enabled...
        if ($project->settings->github['pull_request_environments']) {
          $message = 'Pull Request Received.';

          $branch = $data->pull_request->head->ref;
          $git_url = $data->pull_request->head->repo->ssh_url;

          // Determine environment branch.
          // @TODO: Make Configurable, allow branch names to be env name
          $environment_name = "pr" . $data->pull_request->number;
//          $environment_name = 'branch_' . str_replace('-', '_', $branch);
          $already_have_pr_info = FALSE;

          // When PR is opened... create new environment.
          if ($data->action == 'opened' || $data->action == 'reopened') {
            $message = "Detected Pull Request creation for $branch \n";
            if (isset($project->environments[$environment_name])) {
              $message = "Environment $environment_name already exists! Not creating one... \n";

              // @TODO: Check for environments that are being deleted.
              if (isset($project->environments[$environment_name]->github_pull_request)) {
                $message .= "Already have a PR for $environment_name ... not inserting.";
                $already_have_pr_info = TRUE;
              }
            } else {

              // Create the environment. Settings are inherited from project.
              hosting_create_environment($project, $environment_name, $branch, null, $git_url);

            }
//
//            $project_node = node_load($project->nid);
//            $project = $project_node->project;
//            $environment = $project->environments[$environment_name];
//
//            $owner = $project->github_owner;
//            $repo = $project->github_repo;
//            $message .= "\n About to try to create a deployment for $owner/$repo...  \n";
//
//            // Send a "deployment" to github.
//            try {
//              $token = variable_get('devshop_github_token', '');
//              $client = new \Github\Client();
//              $client->authenticate($token, \Github\AuthMethod::ACCESS_TOKEN);
//
//              $sha = $data->pull_request->head->sha;
//
//              $params = new stdClass();
//              $params->ref = $sha;
//
//              // In GitHub's API, "environment" is just a small string it displays on the pull request:
//              $params->environment = $project->name . '.' . $environment_name;
//                devshop_environment_url($project, $environment_name)
//              ;
//              $params->required_contexts = array();
//
//              // $message .= "\nEnvironment: " . print_r($environment, 1);
//              $message .= "\nDeployment Params: " . print_r($params, 1);
//
//              $post_url = "/repos/$owner/$repo/deployments";
//              $deployment = json_decode($client->getHttpClient()->post($post_url, json_encode($params))->getBody(TRUE));
//
//              // Save deployment to pull request data for later access.
//              $data->pull_request->deployment = $deployment;
//
//              $message .= " Deployment Created! \n";
//
//              // Create deployment status
//              $params = new stdClass();
//              $params->state = 'pending';
//              $params->target_url = $environment->url;;
//              $params->description = t('New environment is being created.  Please stand by.');
//              $deployment_status = $client->getHttpClient()->post("/repos/$owner/$repo/deployments/{$deployment->id}/statuses", json_encode($params));
//
//              $message .= " Deployment Status Created! \n";
//
//              // Set a commit status for this REF for devshop/deploy context
//              $sha = $data->pull_request->head->sha;
//
//              $params = new stdClass();
//              $params->state = 'pending';
//              $params->target_url = url("node/$environment->site", array('absolute' => TRUE));
//              $params->description = t('DevShop: Deploy');
//              $params->context = "devshop/{$project->name}/deploy";
//
//              // Post status to github
//              $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
//              $message .= " Commit Status Created! \n";
//
//              // Determine if we are going to run tests.
//              // For now it is using the "live environment" setting.
//              // @TODO: Once we add "deploy hooks" to "Project Settings: Environment Defaults" we will have to change this.
//
////              // If live environment is set to run tests on deploy...
////              $live_environment = $project->settings->primary_environment;
////              if ($project->environments[$live_environment]->settings->deploy['test']) {
////                $params = new stdClass();
////                $params->state = 'pending';
////                $params->target_url = url(
////                  "node/$environment->site",
////                  array('absolute' => true)
////                );
////                $params->description = t('DevShop: Run Tests');
////                $params->context = 'devshop/tests';
////
////                // Post status to github
////                $status = $client->getHttpClient()->post(
////                  "/repos/$owner/$repo/statuses/$sha",
////                  json_encode($params)
////                );
////                $message .= " Commit Status for pending test run Created! \n";
////              }
//
//            } catch (Github\Exception\RuntimeException $e) {
//              watchdog('devshop_github', 'GitHub Runtime Error: ' . $e->getMessage());
//              $message .= 'GitHub RunTimeException during PR Create: ' . $e->getMessage() . $e->getCode();
//
//              if ($e->getCode() == '409') {
//                $message .= "\n Branch is out of date! alert the developer!";
//
//                // Send a failed commit status to alert to developer
//                $params = new stdClass();
//                $params->state = 'failure';
//                $params->target_url = $project->git_repo_url;
//                $params->description = t('Branch is out of date! Merge from default branch.');
//                $params->context = "devshop/{$project->name}/merge";
//
//                // Post status to github
//                $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
//              }
//              else {
//                http_response_code(500);
//              }
//
//            } catch (Github\Exception\ValidationFailedException $e) {
//              watchdog('devshop_github', 'GitHub Validation Failed Error: ' . $e->getMessage());
//              $message .= 'GitHub ValidationFailedException Error: ' . $e->getMessage();
//            }

            // Insert PR record
            if (!$already_have_pr_info) {
              if (devshop_github_save_pr_env_data($data->pull_request, $project)) {
                $message .= ' ' . t('Pull Request info saved to DevShop.');
              } else {
                $message .= 'Saving PR record failed: ' . print_r($data->pull_request, 1);
              }
            }
          }

//              $info = new stdClass();
//              $info->id = $data->pull_request->id;
//              $info->number = $data->pull_request->number;
//              $info->project_nid = $project->nid;
//              $info->environment_name = $environment_name;
//              $info->pull_request_object = serialize($data->pull_request);
//
//              // Last minute check for existing PR info
//              $results = db_select('hosting_devshop_github_pull_requests', 'pr')
//                ->condition('id', $data->pull_request->id)
//                ->fields('pr', array('id'))
//                ->execute()
//                ->fetchAssoc();
//
//              // If there are results, save $update param for drupal_write_record().
//              if (empty($results)) {
//                $update = array();
//              }
//              else {
//                $update = array('id');
//              }
//
//              // Save environment record.
//              try {
//                drupal_write_record('hosting_devshop_github_pull_requests', $info, $update);
//                $message .= ' ' . t('Pull Request info saved to DevShop.');
//              }
//              catch (\PDOException $e) {
//                $message .= 'Saving PR record failed: ' . $e->getMessage();
//              }
//            }
//          }

          // When PR is updated, send a new deployment status environment.
          elseif ($data->action == 'synchronize') {

            // Create a new deployment
            $owner = $project->github_owner;
            $repo = $project->github_repo;
            $environment = $project->environments[$environment_name];

            // Environment might have been deleted.
            if (!empty($environment)) {
              $message .= "Environment $environment_name not found in project $project->name.";
            }
            else {

              $message .= "About to set deployment status for repo $owner/$repo using environment $environment_name  \n";
              $message .= "Environment: " . print_r($environment, 1);

              try {
                $token = variable_get('devshop_github_token', '');
                $client = new \Github\Client();
                $client->authenticate($token, \Github\AuthMethod::ACCESS_TOKEN);

                $sha = $data->pull_request->head->sha;

                $params = new stdClass();
                $params->ref = $sha;
                $params->environment = $environment->url;
                $params->required_contexts = array();
                $post_url = "/repos/$owner/$repo/deployments";
                $deployment = json_decode($client->getHttpClient()->post($post_url, json_encode($params))->getBody(TRUE));

                // Save deployment to pull request data for later access.
                $data->pull_request->deployment = $deployment;

                $message .= " Deployment Created! \n";

                // Create deployment status
                $deployment_id = $deployment->id;

                $params = new stdClass();
                $params->state = 'pending';
                $params->target_url = $environment->url;
                $params->description = t('Code is being deployed.  Please stand by.');

                $post_url = "/repos/$owner/$repo/deployments/{$deployment_id}/statuses";
                $message .= "Attempting to create deployment status: $post_url \n";

                $deployment_status = $client->getHttpClient()->post($post_url, json_encode($params));

                $message .= " Deployment Status Created! \n";

                // Set a commit status for this REF for devshop/deploy context
                $sha = $data->pull_request->head->sha;

                $params = new stdClass();
                $params->state = 'pending';
                $params->target_url = url("node/$project->nid", array('absolute' => TRUE));
                $params->description = t('DevShop: Deploy');
                $params->context = "devshop/{$project->name}/deploy";

                // Post status to github
                $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));

                $message .= " Commit Status Created! \n";

                // If environment is configured to run tests, add another status.
                if (!empty($environment->settings->deploy['test'])) {
                  $params = new stdClass();
                  $params->state = 'pending';

                  // @TODO: Add the link to the last "test" task here instead of the project.
                  $params->target_url = url("node/$project->nid", array('absolute' => TRUE));
                  $params->description = t('DevShop: Run Tests');
                  $params->context = "devshop/{$project->name}/tests";

                  // Post status to github
                  $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));

                  $message .= " Commit Status Created for test runs! \n";
                }

              } catch (Github\Exception\RuntimeException $e) {
                $log = 'GitHub API Error during PR Syncronize: ' . $e->getMessage() . $e->getCode();
                watchdog('devshop_github', $log);

                if ($e->getCode() == '409') {
                  $log .= "\n Out of date! alert the developer!";

                  // Send a failed commit status to alert to developer
                  $params = new stdClass();
                  $params->state = 'failure';
                  $params->target_url = $project->git_repo_url;
                  $params->description = t('Branch is out of date! Merge from default branch.');
                  $params->context = "devshop/{$project->name}/merge";

                  // Post status to github
                  $status = $client->getHttpClient()->post("/repos/$owner/$repo/statuses/$sha", json_encode($params));
                }
                else {
                  http_response_code(500);
                }
                $message .= $log . "\n";
              }


              // Update the PR record
              $info = new stdClass();
              $info->site_nid = $environment->site;
              $info->id = $data->pull_request->id;
              $info->number = $data->pull_request->number;
              $info->pull_request_object = serialize($data->pull_request);

              // Save environment record.
              $results = db_select('hosting_devshop_github_pull_requests', 'pr')
                  ->condition('id', $data->pull_request->id)
                  ->fields('pr', array('id'))
                  ->execute()
                  ->fetchAssoc();

              // If there are results, save $update param for drupal_write_record().
              if (empty($results)) {
                $update = array();
              }
              else {
                $update = array('id');
              }

              // Save environment record.
              try {
                drupal_write_record('hosting_devshop_github_pull_requests', $info, $update);
                $message .= ' ' . t('Pull Request info saved to DevShop.');
              }
              catch (\PDOException $e) {
                $message .= 'Saving PR record failed: ' . $e->getMessage();
              }
            }
          }
          // When PR is closed, delete environment.
          elseif ($data->action == 'closed') {
            $message .= "Pull Request Closed \n";
            if ($project->settings->github['pull_request_environments_delete']) {

              // If environment has a site... trigger it's deletion.
              // Platform deletion triggers after site deletion completes.
              if ($project->environments[$environment_name]->site) {
                hosting_add_task($project->environments[$environment_name]->site, 'delete', array('force' => 1));
                $message .= "Environment $environment_name (Site Node: {$project->environments[$environment_name]->site}) scheduled for deletion.";
              }
              // If environment has a platform... trigger it's deletion.
              elseif ($project->environments[$environment_name]->platform) {
                hosting_add_task($project->environments[$environment_name]->platform, 'delete');
                $message .= "Environment $environment_name (Platform Node: {$project->environments[$environment_name]->platform}) scheduled for deletion.";
              }
            }
          }
        }
        break;
    }

  }
  else {
    $message = 'GitHub Request Received, but not in JSON. Please make sure to configure the webhook to use Payload version: application/vnd.github.v3+json';
  }
  return $message;
}

/**
 * Check the GitHub account for an SSH key.
 *
 * @return bool
 */
function devshop_github_check_key($silent = false) {

  if (!devshop_public_key_valid_fingerprint()) {
    return FALSE;
  }

  $token = variable_get('devshop_github_token', '');
  if (empty($token)) {
    return FALSE;
  }

  $client = new \Github\Client();
  $client->authenticate($token, \Github\AuthMethod::ACCESS_TOKEN);

  try {
    $keys = $client->currentUser()->keys()->all();
  }
  catch (Exception $e) {
    if (!$silent) {
      drupal_set_message($e->getMessage(), 'error');
    }
    return FALSE;
  }
  foreach ($keys as $key) {
    $ssh_key = sshkey_parse($key['key']);
    if (!empty($ssh_key['fingerprint']) && $ssh_key['fingerprint'] == devshop_public_key_valid_fingerprint()) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * @param $pr
 * @param $environment
 */
function devshop_github_save_pr_env_data($pr, $environment) {
  $info = new stdClass();
  $info->site_nid = $environment->site;
  $info->id = $pr->id;
  $info->number = $pr->number;
  $info->pull_request_object = serialize($pr);

  // Last minute check for existing PR info
  $results = db_select('hosting_devshop_github_pull_requests', 'pr')
    ->condition('id', $pr->id)
    ->fields('pr', array('id'))
    ->execute()
    ->fetchAssoc();

  // If there are results, save $update param for drupal_write_record().
  if (empty($results)) {
    $update = array();
  }
  else {
    $update = array('id');
  }

  // Save environment record.
  try {
    watchdog('devshop_github', t('Pull Request saved for environment !nid !env.', array(
      '!nid' => $environment->site,
      '!env' => l($environment->uri, "node/{$info->site_nid}"),
    )));
    drupal_write_record('hosting_devshop_github_pull_requests', $info, $update);
    return TRUE;
  }
  catch (\PDOException $e) {
    return FALSE;
  }
}

/**
 * Function to create all PR environments for a project. Used by the Github
 * queue and on project Node Insert.
 */
function devshop_github_create_all_pr_environments($project_node) {

  // Load all PRs from GitHub API
  $project = $project_node->project;
  try {
    $prs_data = devshop_github_client()->pullRequests()->all($project->github_owner, $project->github_repo);
  } catch (\Exception $e) {
    drupal_set_message(t("Unable to load Pull Requests: !message", array('!message' => $e->getMessage())));
    return;
  }
  $prs = array();
  foreach ($prs_data as $pr) {
    $pr = convert_to_object($pr);
    $slug = "pr{$pr->number}";
    $prs[$slug] = $pr;
  }
  $prs_to_create_environments_for = $prs;
  $deployed_environments = 0;
  $deleted_environments = 0;

  // Step 1: Update existing existing environments, populate $prs_to_create_environments_for,
  // and queue "delete", "deploy", or "install" tasks for PRs depending on their state.
  // For each existing PR environment on DevShop:
  foreach ($project->environments as $environment) {
    $site_url = url("node/{$environment->site}", array('absolute' => true));

    // Get PR ID, if it already has one.
    if (!empty($environment->github_pull_request->number)) {
      $environment_pr_number = $environment->github_pull_request->number;
      $environment_pr_slug = "pr{$environment_pr_number}";
    }
    else {
      $environment_pr_number = NULL;
      $environment_pr_slug = NULL;
    }

    drush_log("Checking $environment->name... [$site_url]", 'ok');

    // If no PR data in environment and no PR exists with this environments name, it is not a PR environment. Move on.
    if (empty($prs[$environment->name]) && $environment->site_status != HOSTING_SITE_DELETED && empty($environment->github_pull_request)) {
      drush_log("No PR data found in Drupal database for environment [$environment->name] site NID [$environment->site]", 'warning');
      continue;
    }
    // If no PR data, but the environment name matches a PR's slug, update data.
    // Handles the edge case where a pr123 environment lost it's github PR info.
    elseif (!$environment_pr_number && !empty($prs[$environment->name])) {
      devshop_github_save_pr_env_data($prs[$environment->name], $environment);
      drush_log(
        "Environment found with the name '$environment->name'. Assuming it is a PR environment. Updating it with PR data and removing it from the list of environments to create. [$site_url]",
        "warning"
      );
      unset($prs_to_create_environments_for[$environment->name]);
    }
    // If there IS PR data in the environment and the PR exists on GitHub, update the PR data.
    elseif ($environment_pr_number && !empty($prs[$environment_pr_slug]) && !empty($environment->tasks['delete'])) {
      drush_log("Deleted PR environment found: $environment->name [$site_url]", "ok");

      // Save data
      devshop_github_save_pr_env_data($prs[$environment_pr_slug], $environment);
    }
    // If there IS PR data in the environment and the PR exists on GitHub, update the PR data.
    elseif ($environment_pr_number && !empty($prs[$environment_pr_slug])) {
      devshop_github_save_pr_env_data($prs[$environment_pr_slug], $environment);
      drush_log("PR environment found and updated: $environment->name [$site_url]", "ok");

      // If this environment is a "automated" PR environment, unset it from the list of envs to create.
      if ($environment_pr_slug == $environment->name) {
        unset($prs_to_create_environments_for[$environment_pr_slug]);
      }
    }
    // If there IS PR data stored on this environment but the PR does NOT exist,
    elseif ($environment_pr_number && empty($prs[$environment_pr_slug]) && $environment->site_status == HOSTING_SITE_DELETED) {
      drush_log("PR environment already deleted: $environment->name [$site_url]", "ok");
    }

    // If there IS PR data stored on this environment but the PR does NOT exist, and the site isn't already deleted, queue delete task.
    elseif ($environment_pr_number && empty($prs[$environment_pr_slug]) && $environment->site_status != HOSTING_SITE_DELETED) {
      drush_log("PR $environment_pr_number environment $environment->name exists but PR has been closed. [$site_url] [PR Slug $environment_pr_slug]", "ok");

      $delete_tasks_running = isset($environment->tasks['delete']) && array_filter($environment->tasks['delete'], function($value) {
        return $value->task_status == HOSTING_TASK_QUEUED || $value->task_status == HOSTING_TASK_PROCESSING;
      });

      if ($project->settings->github['pull_request_environments_delete'] && empty($delete_tasks_running)) {
        drush_log("PR environment scheduled for deletion: $environment->name [$site_url]","ok");
        hosting_add_task($environment->site, 'delete', array('force' => 1));
        $deleted_environments++;
      }
      elseif ($delete_tasks_running) {
        drush_log("PR environment already scheduled for deletion: $environment->name [$site_url]", "ok");
      }

      // Since this PR is closed, and the site is scheduled for deletion, don't
      // run any further tasks on the site.
      continue;
    }

    drush_log("PR Processing complete for $environment->name", "ok");
    drush_log("", "ok");
    drush_log("", "ok");
    drush_log("", "ok");

  }

  // Step 2: For all PRS that do not have an environment, create one.
  foreach ($prs_to_create_environments_for as $slug => $pr) {
    $branch = $pr->head->ref;

    // If PR has different remote URL, set it.
    if ($pr->head->repo->fork) {
      // Try to match project URL scheme
      if (strpos($project->git_url, 'git://') === 0){
        $remote_url = $pr->head->repo->git_url;
      }
      elseif (strpos($project->git_url, 'git@') === 0){
        $remote_url = $pr->head->repo->ssh_url;
      }
      else {
        $remote_url = $pr->head->repo->clone_url;
      }
    }

    // If not a fork, use the same git_ref as project.
    else {
      $remote_url = $project->git_ref;
    }

    // @TODO: Create a "PR Env pattern" setting.
    $environment_name = $slug;

    // Create "environment". (site node)
    $environment = hosting_create_environment($project, $environment_name, $branch, NULL, NULL, 'create', $remote_url);
    devshop_bitbucket_save_pr_env_data($pr, $environment);
  }

  // Process $prs_to_create_environments_for
  drush_log( format_plural(count($prs_to_create_environments_for),  "1 environment created.", t("!count Environments created.", array(
    "!count" => count($prs_to_create_environments_for),
  ))), "ok");

  drush_log( format_plural($deployed_environments,  "1 Environment Updated.", t("!count Environments Updated.", array(
    "!count" => $deployed_environments,
  ))), "ok");

  drush_log( format_plural($deleted_environments,  "1 Environment Deleted.", t("!count Environments Deleted.", array(
    "!count" => $deleted_environments,
  ))), "ok");
}

/**
 * Implements hook_devshop_post_environment_create().
 */
function devshop_github_devshop_post_environment_create($environment) {
//  DevShopGitHubApi::createDeployment($environment, 'pending');
}

/**
 * Get the git sha from the desired path.
 *
 * @param $repo_path
 *
 * @return string
 */
function devshop_environment_get_git_sha($repo_path) {
  return trim(shell_exec("cd {$repo_path}; git rev-parse HEAD  2> /dev/null"));
}


/**
 * Preprocessor for environment template.
 */
function devshop_github_preprocess_environment(&$vars) {

  // Pull Request?
  $environment = &$vars['environment'];
  if (isset($environment->github_pull_request) && $environment->github_pull_request) {
    $environment->class .= ' pull-request';
    $vars['warnings'][] = array(
      'type' => 'info',
      'icon' => 'github',
      'text' => l($environment->github_pull_request->pull_request_object->title, $environment->github_pull_request->pull_request_object->html_url, array(
        'absolute' => TRUE,
        'attributes' => array(
          'target' => '_blank',
          'title' => t('Visit this Pull Request on GitHub'),
        ),
      )),
    );
  }
}
